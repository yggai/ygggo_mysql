# 性能基准测试功能

## 概述

ygggo_mysql 提供了全面的性能基准测试功能，帮助开发者评估数据库操作的性能，识别瓶颈，并优化应用程序的数据库访问模式。该功能支持多种测试类型、详细的性能指标收集和多格式的报告生成。

## 核心特性

### 🚀 主要功能

- **多种测试类型**：支持连接、查询、事务、批量操作等多种基准测试
- **灵活配置**：可配置测试时长、并发数、预热时间等参数
- **实时监控**：支持测试过程中的实时进度报告
- **详细指标**：收集吞吐量、延迟、百分位数等详细性能指标
- **多格式报告**：支持文本、JSON、CSV等多种格式的报告生成
- **性能分析**：提供性能对比分析和优化建议

### 📊 性能指标

- **吞吐量（TPS/QPS）**：每秒事务数/查询数
- **延迟统计**：平均、最小、最大延迟
- **百分位延迟**：P50、P95、P99延迟分布
- **成功率**：操作成功与失败的比例
- **资源使用**：连接数、内存使用等资源指标
- **错误分析**：详细的错误统计和分类

## 快速开始

### 基本使用

```go
package main

import (
    "context"
    "time"
    "github.com/yggai/ygggo_mysql"
)

func main() {
    ctx := context.Background()
    
    // 创建数据库连接池
    pool, err := ygggo_mysql.NewPool(ctx, ygggo_mysql.Config{
        // 数据库配置...
    })
    if err != nil {
        panic(err)
    }
    defer pool.Close()
    
    // 配置基准测试
    config := ygggo_mysql.DefaultBenchmarkConfig()
    config.Duration = 30 * time.Second
    config.Concurrency = 10
    config.WarmupTime = 5 * time.Second
    
    // 创建基准测试运行器
    runner := ygggo_mysql.NewBenchmarkRunner(config, pool)
    
    // 创建测试实例
    test := ygggo_mysql.NewSelectBenchmarkTest(1000) // 1000行测试数据
    
    // 运行基准测试
    result, err := runner.RunBenchmark(ctx, test)
    if err != nil {
        panic(err)
    }
    
    // 输出结果
    fmt.Printf("测试: %s\n", result.TestName)
    fmt.Printf("吞吐量: %.2f ops/sec\n", result.ThroughputOPS)
    fmt.Printf("平均延迟: %v\n", result.AvgLatency)
    fmt.Printf("P95延迟: %v\n", result.P95Latency)
}
```

## 配置选项

### BenchmarkConfig

```go
type BenchmarkConfig struct {
    Duration       time.Duration // 测试持续时间
    Concurrency    int           // 并发工作线程数
    Iterations     int           // 迭代次数（0表示基于时间）
    WarmupTime     time.Duration // 预热时间
    DataSize       int           // 测试数据大小
    TableName      string        // 测试表名
    CleanupData    bool          // 是否清理测试数据
    ReportInterval time.Duration // 进度报告间隔
    CollectMetrics bool          // 是否收集详细指标
}
```

### 默认配置

```go
config := ygggo_mysql.DefaultBenchmarkConfig()
// Duration: 30s
// Concurrency: 10
// WarmupTime: 5s
// DataSize: 1000
// CleanupData: true
// ReportInterval: 5s
// CollectMetrics: true
```

## 内置基准测试

### 1. 简单查询测试

测试基本的SELECT查询性能：

```go
// 简单查询测试
type SimpleBenchmarkTest struct{}

func (t *SimpleBenchmarkTest) Run(ctx context.Context, pool DatabasePool, workerID int) error {
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        rows, err := conn.Query(ctx, "SELECT 1")
        if err != nil {
            return err
        }
        defer rows.Close()
        return nil
    })
}
```

### 2. SELECT性能测试

测试不同复杂度的SELECT查询：

```go
// 创建SELECT基准测试，包含1000行测试数据
test := ygggo_mysql.NewSelectBenchmarkTest(1000)

result, err := runner.RunBenchmark(ctx, test)
```

**测试类型**：
- 点查询（根据ID查询）
- 范围查询（WHERE条件查询）
- 聚合查询（COUNT、AVG、MAX等）
- 模式匹配（LIKE查询）

### 3. INSERT性能测试

测试插入操作的性能：

```go
// 单条插入测试
test := ygggo_mysql.NewInsertPerformanceBenchmarkTest(1)

// 批量插入测试
test := ygggo_mysql.NewInsertPerformanceBenchmarkTest(10) // 批量大小为10
```

### 4. UPDATE性能测试

测试更新操作的性能：

```go
test := ygggo_mysql.NewUpdateBenchmarkTest(500) // 500行数据进行更新测试
```

### 5. 批量操作测试

测试批量插入的性能：

```go
test := ygggo_mysql.NewBulkOperationBenchmarkTest(20) // 批量大小为20
```

### 6. 混合工作负载测试

测试读写混合的工作负载：

```go
// 70%读操作，30%写操作
test := ygggo_mysql.NewMixedWorkloadBenchmarkTest(1000, 0.7)
```

## 基准测试套件

### 运行多个测试

```go
// 创建测试套件
suite := ygggo_mysql.NewBenchmarkSuite(config)

// 添加多个测试
suite.AddTest(&SimpleBenchmarkTest{})
suite.AddTest(ygggo_mysql.NewSelectBenchmarkTest(500))
suite.AddTest(ygggo_mysql.NewInsertPerformanceBenchmarkTest(1))
suite.AddTest(ygggo_mysql.NewUpdateBenchmarkTest(200))

// 运行所有测试
results, err := suite.RunAll(ctx, pool)
if err != nil {
    panic(err)
}

// 处理结果
for _, result := range results {
    fmt.Printf("%s: %.2f ops/sec\n", result.TestName, result.ThroughputOPS)
}
```

## 性能报告生成

### 创建报告生成器

```go
generator := ygggo_mysql.NewBenchmarkReportGenerator()
generator.AddResults(results)
```

### 文本报告

```go
// 生成文本报告
err := generator.WriteTextReport(os.Stdout)
```

**输出示例**：
```
Benchmark Report
Generated at: 2024-01-15T10:30:00Z
================

Summary:
  Total Tests: 4
  Total Duration: 2m30s
  Total Operations: 125000
  Overall Throughput: 833.33 ops/sec
  Average Latency: 12ms
  Best Performer: Simple Query Test
  Worst Performer: Bulk Operation Test

Individual Results:
==================

1. Simple Query Test
   Duration: 30s
   Operations: 45000 (Success: 45000, Errors: 0)
   Throughput: 1500.00 ops/sec
   Latency: avg=6ms, min=1ms, max=25ms
   Percentiles: P50=5ms, P95=15ms, P99=22ms
   Peak Connections: 10
```

### JSON报告

```go
// 生成JSON报告
file, _ := os.Create("benchmark_report.json")
defer file.Close()
err := generator.WriteJSONReport(file)
```

### CSV报告

```go
// 生成CSV报告
file, _ := os.Create("benchmark_report.csv")
defer file.Close()
err := generator.WriteCSVReport(file)
```

## 性能分析

### 获取最佳性能者

```go
// 获取前3名性能最佳的测试
topPerformers := generator.GetTopPerformers(3)
for i, result := range topPerformers {
    fmt.Printf("%d. %s: %.2f ops/sec\n", 
        i+1, result.TestName, result.ThroughputOPS)
}
```

### 性能对比

```go
report := generator.GenerateReport()

// 查看性能对比
for _, comp := range report.Comparisons {
    fmt.Printf("%s vs %s (%s): %s is %.2f%% better\n",
        comp.TestA, comp.TestB, comp.Metric, comp.Better, comp.Difference)
}
```

## 自定义基准测试

### 实现BenchmarkTest接口

```go
type CustomBenchmarkTest struct {
    TableName string
    DataSize  int
}

func (t *CustomBenchmarkTest) Name() string {
    return "Custom Performance Test"
}

func (t *CustomBenchmarkTest) Setup(ctx context.Context, pool DatabasePool) error {
    // 设置测试环境
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, fmt.Sprintf(`
            CREATE TABLE %s (
                id INTEGER PRIMARY KEY,
                data TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, t.TableName))
        return err
    })
}

func (t *CustomBenchmarkTest) Run(ctx context.Context, pool DatabasePool, workerID int) error {
    // 执行单次操作
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, 
            fmt.Sprintf("INSERT INTO %s (data) VALUES (?)", t.TableName),
            fmt.Sprintf("worker_%d_data", workerID))
        return err
    })
}

func (t *CustomBenchmarkTest) Cleanup(ctx context.Context, pool DatabasePool) error {
    // 清理测试环境
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, fmt.Sprintf("DROP TABLE IF EXISTS %s", t.TableName))
        return err
    })
}
```

### 使用自定义测试

```go
customTest := &CustomBenchmarkTest{
    TableName: "custom_test_table",
    DataSize:  1000,
}

result, err := runner.RunBenchmark(ctx, customTest)
```

## 最佳实践

### 1. 测试环境配置

```go
// 生产环境基准测试配置
config := ygggo_mysql.BenchmarkConfig{
    Duration:       60 * time.Second,  // 较长的测试时间
    Concurrency:    20,                // 适中的并发数
    WarmupTime:     10 * time.Second,  // 充分的预热时间
    ReportInterval: 10 * time.Second,  // 适当的报告间隔
    CleanupData:    true,              // 清理测试数据
}

// 开发环境基准测试配置
config := ygggo_mysql.BenchmarkConfig{
    Duration:       10 * time.Second,  // 较短的测试时间
    Concurrency:    5,                 // 较低的并发数
    WarmupTime:     2 * time.Second,   // 较短的预热时间
    ReportInterval: 5 * time.Second,   // 频繁的进度报告
    CleanupData:    true,              // 清理测试数据
}
```

### 2. 性能监控

```go
// 启用实时进度报告
config.ReportInterval = 5 * time.Second

// 运行基准测试时会输出：
// Progress: 1500 ops, 150.00 ops/sec, 2 errors
// Progress: 3200 ops, 160.00 ops/sec, 3 errors
```

### 3. 错误处理

```go
result, err := runner.RunBenchmark(ctx, test)
if err != nil {
    log.Printf("Benchmark failed: %v", err)
    return
}

// 检查错误率
errorRate := float64(result.ErrorOps) / float64(result.TotalOps) * 100
if errorRate > 5.0 { // 错误率超过5%
    log.Printf("High error rate: %.2f%%", errorRate)
    for _, err := range result.Errors {
        log.Printf("Error: %s (count: %d)", err.Message, err.Count)
    }
}
```

### 4. 性能基线建立

```go
// 建立性能基线
baseline := map[string]float64{
    "Simple Query":     1000.0, // ops/sec
    "SELECT Benchmark": 800.0,
    "INSERT Benchmark": 500.0,
}

// 与基线对比
for _, result := range results {
    if expected, ok := baseline[result.TestName]; ok {
        ratio := result.ThroughputOPS / expected
        if ratio < 0.8 { // 性能下降超过20%
            log.Printf("Performance regression in %s: %.2f%% of baseline", 
                result.TestName, ratio*100)
        }
    }
}
```

## 故障排查

### 常见问题

1. **测试失败或错误率高**
   - 检查数据库连接配置
   - 降低并发数
   - 增加测试时长
   - 检查数据库资源限制

2. **性能结果不稳定**
   - 增加预热时间
   - 延长测试持续时间
   - 确保测试环境稳定
   - 避免其他进程干扰

3. **内存使用过高**
   - 减少数据大小
   - 降低并发数
   - 启用数据清理

### 调试技巧

```go
// 启用详细日志
pool.EnableLogging(true)

// 检查测试配置
fmt.Printf("Config: %+v\n", config)

// 分析错误详情
if len(result.Errors) > 0 {
    for _, err := range result.Errors {
        fmt.Printf("Error: %s (count: %d, timestamp: %v)\n", 
            err.Message, err.Count, err.Timestamp)
    }
}
```

## 示例代码

完整的示例代码请参考：[examples/benchmark_example.go](../examples/benchmark_example.go)

该示例展示了：
- 基本基准测试配置和运行
- 多种内置测试类型的使用
- 基准测试套件的创建和执行
- 多格式报告生成
- 性能分析和对比
- 自定义基准测试的实现

## 总结

性能基准测试功能为数据库性能评估和优化提供了强大的工具。通过系统性的性能测试，可以：

- **识别性能瓶颈**：发现应用中的性能问题
- **验证优化效果**：量化优化措施的效果
- **建立性能基线**：为持续性能监控提供参考
- **指导架构决策**：基于实际性能数据做出技术选择

合理使用基准测试功能，可以显著提升应用的数据库性能和用户体验。
