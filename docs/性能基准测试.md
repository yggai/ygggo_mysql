# æ€§èƒ½åŸºå‡†æµ‹è¯•åŠŸèƒ½

## æ¦‚è¿°

ygggo_mysql æä¾›äº†å…¨é¢çš„æ€§èƒ½åŸºå‡†æµ‹è¯•åŠŸèƒ½ï¼Œå¸®åŠ©å¼€å‘è€…è¯„ä¼°æ•°æ®åº“æ“ä½œçš„æ€§èƒ½ï¼Œè¯†åˆ«ç“¶é¢ˆï¼Œå¹¶ä¼˜åŒ–åº”ç”¨ç¨‹åºçš„æ•°æ®åº“è®¿é—®æ¨¡å¼ã€‚è¯¥åŠŸèƒ½æ”¯æŒå¤šç§æµ‹è¯•ç±»å‹ã€è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œå¤šæ ¼å¼çš„æŠ¥å‘Šç”Ÿæˆã€‚

## æ ¸å¿ƒç‰¹æ€§

### ğŸš€ ä¸»è¦åŠŸèƒ½

- **å¤šç§æµ‹è¯•ç±»å‹**ï¼šæ”¯æŒè¿æ¥ã€æŸ¥è¯¢ã€äº‹åŠ¡ã€æ‰¹é‡æ“ä½œç­‰å¤šç§åŸºå‡†æµ‹è¯•
- **çµæ´»é…ç½®**ï¼šå¯é…ç½®æµ‹è¯•æ—¶é•¿ã€å¹¶å‘æ•°ã€é¢„çƒ­æ—¶é—´ç­‰å‚æ•°
- **å®æ—¶ç›‘æ§**ï¼šæ”¯æŒæµ‹è¯•è¿‡ç¨‹ä¸­çš„å®æ—¶è¿›åº¦æŠ¥å‘Š
- **è¯¦ç»†æŒ‡æ ‡**ï¼šæ”¶é›†ååé‡ã€å»¶è¿Ÿã€ç™¾åˆ†ä½æ•°ç­‰è¯¦ç»†æ€§èƒ½æŒ‡æ ‡
- **å¤šæ ¼å¼æŠ¥å‘Š**ï¼šæ”¯æŒæ–‡æœ¬ã€JSONã€CSVç­‰å¤šç§æ ¼å¼çš„æŠ¥å‘Šç”Ÿæˆ
- **æ€§èƒ½åˆ†æ**ï¼šæä¾›æ€§èƒ½å¯¹æ¯”åˆ†æå’Œä¼˜åŒ–å»ºè®®

### ğŸ“Š æ€§èƒ½æŒ‡æ ‡

- **ååé‡ï¼ˆTPS/QPSï¼‰**ï¼šæ¯ç§’äº‹åŠ¡æ•°/æŸ¥è¯¢æ•°
- **å»¶è¿Ÿç»Ÿè®¡**ï¼šå¹³å‡ã€æœ€å°ã€æœ€å¤§å»¶è¿Ÿ
- **ç™¾åˆ†ä½å»¶è¿Ÿ**ï¼šP50ã€P95ã€P99å»¶è¿Ÿåˆ†å¸ƒ
- **æˆåŠŸç‡**ï¼šæ“ä½œæˆåŠŸä¸å¤±è´¥çš„æ¯”ä¾‹
- **èµ„æºä½¿ç”¨**ï¼šè¿æ¥æ•°ã€å†…å­˜ä½¿ç”¨ç­‰èµ„æºæŒ‡æ ‡
- **é”™è¯¯åˆ†æ**ï¼šè¯¦ç»†çš„é”™è¯¯ç»Ÿè®¡å’Œåˆ†ç±»

## å¿«é€Ÿå¼€å§‹

### åŸºæœ¬ä½¿ç”¨

```go
package main

import (
    "context"
    "time"
    "github.com/yggai/ygggo_mysql"
)

func main() {
    ctx := context.Background()
    
    // åˆ›å»ºæ•°æ®åº“è¿æ¥æ± 
    pool, err := ygggo_mysql.NewPool(ctx, ygggo_mysql.Config{
        // æ•°æ®åº“é…ç½®...
    })
    if err != nil {
        panic(err)
    }
    defer pool.Close()
    
    // é…ç½®åŸºå‡†æµ‹è¯•
    config := ygggo_mysql.DefaultBenchmarkConfig()
    config.Duration = 30 * time.Second
    config.Concurrency = 10
    config.WarmupTime = 5 * time.Second
    
    // åˆ›å»ºåŸºå‡†æµ‹è¯•è¿è¡Œå™¨
    runner := ygggo_mysql.NewBenchmarkRunner(config, pool)
    
    // åˆ›å»ºæµ‹è¯•å®ä¾‹
    test := ygggo_mysql.NewSelectBenchmarkTest(1000) // 1000è¡Œæµ‹è¯•æ•°æ®
    
    // è¿è¡ŒåŸºå‡†æµ‹è¯•
    result, err := runner.RunBenchmark(ctx, test)
    if err != nil {
        panic(err)
    }
    
    // è¾“å‡ºç»“æœ
    fmt.Printf("æµ‹è¯•: %s\n", result.TestName)
    fmt.Printf("ååé‡: %.2f ops/sec\n", result.ThroughputOPS)
    fmt.Printf("å¹³å‡å»¶è¿Ÿ: %v\n", result.AvgLatency)
    fmt.Printf("P95å»¶è¿Ÿ: %v\n", result.P95Latency)
}
```

## é…ç½®é€‰é¡¹

### BenchmarkConfig

```go
type BenchmarkConfig struct {
    Duration       time.Duration // æµ‹è¯•æŒç»­æ—¶é—´
    Concurrency    int           // å¹¶å‘å·¥ä½œçº¿ç¨‹æ•°
    Iterations     int           // è¿­ä»£æ¬¡æ•°ï¼ˆ0è¡¨ç¤ºåŸºäºæ—¶é—´ï¼‰
    WarmupTime     time.Duration // é¢„çƒ­æ—¶é—´
    DataSize       int           // æµ‹è¯•æ•°æ®å¤§å°
    TableName      string        // æµ‹è¯•è¡¨å
    CleanupData    bool          // æ˜¯å¦æ¸…ç†æµ‹è¯•æ•°æ®
    ReportInterval time.Duration // è¿›åº¦æŠ¥å‘Šé—´éš”
    CollectMetrics bool          // æ˜¯å¦æ”¶é›†è¯¦ç»†æŒ‡æ ‡
}
```

### é»˜è®¤é…ç½®

```go
config := ygggo_mysql.DefaultBenchmarkConfig()
// Duration: 30s
// Concurrency: 10
// WarmupTime: 5s
// DataSize: 1000
// CleanupData: true
// ReportInterval: 5s
// CollectMetrics: true
```

## å†…ç½®åŸºå‡†æµ‹è¯•

### 1. ç®€å•æŸ¥è¯¢æµ‹è¯•

æµ‹è¯•åŸºæœ¬çš„SELECTæŸ¥è¯¢æ€§èƒ½ï¼š

```go
// ç®€å•æŸ¥è¯¢æµ‹è¯•
type SimpleBenchmarkTest struct{}

func (t *SimpleBenchmarkTest) Run(ctx context.Context, pool DatabasePool, workerID int) error {
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        rows, err := conn.Query(ctx, "SELECT 1")
        if err != nil {
            return err
        }
        defer rows.Close()
        return nil
    })
}
```

### 2. SELECTæ€§èƒ½æµ‹è¯•

æµ‹è¯•ä¸åŒå¤æ‚åº¦çš„SELECTæŸ¥è¯¢ï¼š

```go
// åˆ›å»ºSELECTåŸºå‡†æµ‹è¯•ï¼ŒåŒ…å«1000è¡Œæµ‹è¯•æ•°æ®
test := ygggo_mysql.NewSelectBenchmarkTest(1000)

result, err := runner.RunBenchmark(ctx, test)
```

**æµ‹è¯•ç±»å‹**ï¼š
- ç‚¹æŸ¥è¯¢ï¼ˆæ ¹æ®IDæŸ¥è¯¢ï¼‰
- èŒƒå›´æŸ¥è¯¢ï¼ˆWHEREæ¡ä»¶æŸ¥è¯¢ï¼‰
- èšåˆæŸ¥è¯¢ï¼ˆCOUNTã€AVGã€MAXç­‰ï¼‰
- æ¨¡å¼åŒ¹é…ï¼ˆLIKEæŸ¥è¯¢ï¼‰

### 3. INSERTæ€§èƒ½æµ‹è¯•

æµ‹è¯•æ’å…¥æ“ä½œçš„æ€§èƒ½ï¼š

```go
// å•æ¡æ’å…¥æµ‹è¯•
test := ygggo_mysql.NewInsertPerformanceBenchmarkTest(1)

// æ‰¹é‡æ’å…¥æµ‹è¯•
test := ygggo_mysql.NewInsertPerformanceBenchmarkTest(10) // æ‰¹é‡å¤§å°ä¸º10
```

### 4. UPDATEæ€§èƒ½æµ‹è¯•

æµ‹è¯•æ›´æ–°æ“ä½œçš„æ€§èƒ½ï¼š

```go
test := ygggo_mysql.NewUpdateBenchmarkTest(500) // 500è¡Œæ•°æ®è¿›è¡Œæ›´æ–°æµ‹è¯•
```

### 5. æ‰¹é‡æ“ä½œæµ‹è¯•

æµ‹è¯•æ‰¹é‡æ’å…¥çš„æ€§èƒ½ï¼š

```go
test := ygggo_mysql.NewBulkOperationBenchmarkTest(20) // æ‰¹é‡å¤§å°ä¸º20
```

### 6. æ··åˆå·¥ä½œè´Ÿè½½æµ‹è¯•

æµ‹è¯•è¯»å†™æ··åˆçš„å·¥ä½œè´Ÿè½½ï¼š

```go
// 70%è¯»æ“ä½œï¼Œ30%å†™æ“ä½œ
test := ygggo_mysql.NewMixedWorkloadBenchmarkTest(1000, 0.7)
```

## åŸºå‡†æµ‹è¯•å¥—ä»¶

### è¿è¡Œå¤šä¸ªæµ‹è¯•

```go
// åˆ›å»ºæµ‹è¯•å¥—ä»¶
suite := ygggo_mysql.NewBenchmarkSuite(config)

// æ·»åŠ å¤šä¸ªæµ‹è¯•
suite.AddTest(&SimpleBenchmarkTest{})
suite.AddTest(ygggo_mysql.NewSelectBenchmarkTest(500))
suite.AddTest(ygggo_mysql.NewInsertPerformanceBenchmarkTest(1))
suite.AddTest(ygggo_mysql.NewUpdateBenchmarkTest(200))

// è¿è¡Œæ‰€æœ‰æµ‹è¯•
results, err := suite.RunAll(ctx, pool)
if err != nil {
    panic(err)
}

// å¤„ç†ç»“æœ
for _, result := range results {
    fmt.Printf("%s: %.2f ops/sec\n", result.TestName, result.ThroughputOPS)
}
```

## æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ

### åˆ›å»ºæŠ¥å‘Šç”Ÿæˆå™¨

```go
generator := ygggo_mysql.NewBenchmarkReportGenerator()
generator.AddResults(results)
```

### æ–‡æœ¬æŠ¥å‘Š

```go
// ç”Ÿæˆæ–‡æœ¬æŠ¥å‘Š
err := generator.WriteTextReport(os.Stdout)
```

**è¾“å‡ºç¤ºä¾‹**ï¼š
```
Benchmark Report
Generated at: 2024-01-15T10:30:00Z
================

Summary:
  Total Tests: 4
  Total Duration: 2m30s
  Total Operations: 125000
  Overall Throughput: 833.33 ops/sec
  Average Latency: 12ms
  Best Performer: Simple Query Test
  Worst Performer: Bulk Operation Test

Individual Results:
==================

1. Simple Query Test
   Duration: 30s
   Operations: 45000 (Success: 45000, Errors: 0)
   Throughput: 1500.00 ops/sec
   Latency: avg=6ms, min=1ms, max=25ms
   Percentiles: P50=5ms, P95=15ms, P99=22ms
   Peak Connections: 10
```

### JSONæŠ¥å‘Š

```go
// ç”ŸæˆJSONæŠ¥å‘Š
file, _ := os.Create("benchmark_report.json")
defer file.Close()
err := generator.WriteJSONReport(file)
```

### CSVæŠ¥å‘Š

```go
// ç”ŸæˆCSVæŠ¥å‘Š
file, _ := os.Create("benchmark_report.csv")
defer file.Close()
err := generator.WriteCSVReport(file)
```

## æ€§èƒ½åˆ†æ

### è·å–æœ€ä½³æ€§èƒ½è€…

```go
// è·å–å‰3åæ€§èƒ½æœ€ä½³çš„æµ‹è¯•
topPerformers := generator.GetTopPerformers(3)
for i, result := range topPerformers {
    fmt.Printf("%d. %s: %.2f ops/sec\n", 
        i+1, result.TestName, result.ThroughputOPS)
}
```

### æ€§èƒ½å¯¹æ¯”

```go
report := generator.GenerateReport()

// æŸ¥çœ‹æ€§èƒ½å¯¹æ¯”
for _, comp := range report.Comparisons {
    fmt.Printf("%s vs %s (%s): %s is %.2f%% better\n",
        comp.TestA, comp.TestB, comp.Metric, comp.Better, comp.Difference)
}
```

## è‡ªå®šä¹‰åŸºå‡†æµ‹è¯•

### å®ç°BenchmarkTestæ¥å£

```go
type CustomBenchmarkTest struct {
    TableName string
    DataSize  int
}

func (t *CustomBenchmarkTest) Name() string {
    return "Custom Performance Test"
}

func (t *CustomBenchmarkTest) Setup(ctx context.Context, pool DatabasePool) error {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, fmt.Sprintf(`
            CREATE TABLE %s (
                id INTEGER PRIMARY KEY,
                data TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `, t.TableName))
        return err
    })
}

func (t *CustomBenchmarkTest) Run(ctx context.Context, pool DatabasePool, workerID int) error {
    // æ‰§è¡Œå•æ¬¡æ“ä½œ
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, 
            fmt.Sprintf("INSERT INTO %s (data) VALUES (?)", t.TableName),
            fmt.Sprintf("worker_%d_data", workerID))
        return err
    })
}

func (t *CustomBenchmarkTest) Cleanup(ctx context.Context, pool DatabasePool) error {
    // æ¸…ç†æµ‹è¯•ç¯å¢ƒ
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        _, err := conn.Exec(ctx, fmt.Sprintf("DROP TABLE IF EXISTS %s", t.TableName))
        return err
    })
}
```

### ä½¿ç”¨è‡ªå®šä¹‰æµ‹è¯•

```go
customTest := &CustomBenchmarkTest{
    TableName: "custom_test_table",
    DataSize:  1000,
}

result, err := runner.RunBenchmark(ctx, customTest)
```

## æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç¯å¢ƒé…ç½®

```go
// ç”Ÿäº§ç¯å¢ƒåŸºå‡†æµ‹è¯•é…ç½®
config := ygggo_mysql.BenchmarkConfig{
    Duration:       60 * time.Second,  // è¾ƒé•¿çš„æµ‹è¯•æ—¶é—´
    Concurrency:    20,                // é€‚ä¸­çš„å¹¶å‘æ•°
    WarmupTime:     10 * time.Second,  // å……åˆ†çš„é¢„çƒ­æ—¶é—´
    ReportInterval: 10 * time.Second,  // é€‚å½“çš„æŠ¥å‘Šé—´éš”
    CleanupData:    true,              // æ¸…ç†æµ‹è¯•æ•°æ®
}

// å¼€å‘ç¯å¢ƒåŸºå‡†æµ‹è¯•é…ç½®
config := ygggo_mysql.BenchmarkConfig{
    Duration:       10 * time.Second,  // è¾ƒçŸ­çš„æµ‹è¯•æ—¶é—´
    Concurrency:    5,                 // è¾ƒä½çš„å¹¶å‘æ•°
    WarmupTime:     2 * time.Second,   // è¾ƒçŸ­çš„é¢„çƒ­æ—¶é—´
    ReportInterval: 5 * time.Second,   // é¢‘ç¹çš„è¿›åº¦æŠ¥å‘Š
    CleanupData:    true,              // æ¸…ç†æµ‹è¯•æ•°æ®
}
```

### 2. æ€§èƒ½ç›‘æ§

```go
// å¯ç”¨å®æ—¶è¿›åº¦æŠ¥å‘Š
config.ReportInterval = 5 * time.Second

// è¿è¡ŒåŸºå‡†æµ‹è¯•æ—¶ä¼šè¾“å‡ºï¼š
// Progress: 1500 ops, 150.00 ops/sec, 2 errors
// Progress: 3200 ops, 160.00 ops/sec, 3 errors
```

### 3. é”™è¯¯å¤„ç†

```go
result, err := runner.RunBenchmark(ctx, test)
if err != nil {
    log.Printf("Benchmark failed: %v", err)
    return
}

// æ£€æŸ¥é”™è¯¯ç‡
errorRate := float64(result.ErrorOps) / float64(result.TotalOps) * 100
if errorRate > 5.0 { // é”™è¯¯ç‡è¶…è¿‡5%
    log.Printf("High error rate: %.2f%%", errorRate)
    for _, err := range result.Errors {
        log.Printf("Error: %s (count: %d)", err.Message, err.Count)
    }
}
```

### 4. æ€§èƒ½åŸºçº¿å»ºç«‹

```go
// å»ºç«‹æ€§èƒ½åŸºçº¿
baseline := map[string]float64{
    "Simple Query":     1000.0, // ops/sec
    "SELECT Benchmark": 800.0,
    "INSERT Benchmark": 500.0,
}

// ä¸åŸºçº¿å¯¹æ¯”
for _, result := range results {
    if expected, ok := baseline[result.TestName]; ok {
        ratio := result.ThroughputOPS / expected
        if ratio < 0.8 { // æ€§èƒ½ä¸‹é™è¶…è¿‡20%
            log.Printf("Performance regression in %s: %.2f%% of baseline", 
                result.TestName, ratio*100)
        }
    }
}
```

## æ•…éšœæ’æŸ¥

### å¸¸è§é—®é¢˜

1. **æµ‹è¯•å¤±è´¥æˆ–é”™è¯¯ç‡é«˜**
   - æ£€æŸ¥æ•°æ®åº“è¿æ¥é…ç½®
   - é™ä½å¹¶å‘æ•°
   - å¢åŠ æµ‹è¯•æ—¶é•¿
   - æ£€æŸ¥æ•°æ®åº“èµ„æºé™åˆ¶

2. **æ€§èƒ½ç»“æœä¸ç¨³å®š**
   - å¢åŠ é¢„çƒ­æ—¶é—´
   - å»¶é•¿æµ‹è¯•æŒç»­æ—¶é—´
   - ç¡®ä¿æµ‹è¯•ç¯å¢ƒç¨³å®š
   - é¿å…å…¶ä»–è¿›ç¨‹å¹²æ‰°

3. **å†…å­˜ä½¿ç”¨è¿‡é«˜**
   - å‡å°‘æ•°æ®å¤§å°
   - é™ä½å¹¶å‘æ•°
   - å¯ç”¨æ•°æ®æ¸…ç†

### è°ƒè¯•æŠ€å·§

```go
// å¯ç”¨è¯¦ç»†æ—¥å¿—
pool.EnableLogging(true)

// æ£€æŸ¥æµ‹è¯•é…ç½®
fmt.Printf("Config: %+v\n", config)

// åˆ†æé”™è¯¯è¯¦æƒ…
if len(result.Errors) > 0 {
    for _, err := range result.Errors {
        fmt.Printf("Error: %s (count: %d, timestamp: %v)\n", 
            err.Message, err.Count, err.Timestamp)
    }
}
```

## ç¤ºä¾‹ä»£ç 

å®Œæ•´çš„ç¤ºä¾‹ä»£ç è¯·å‚è€ƒï¼š[examples/benchmark_example.go](../examples/benchmark_example.go)

è¯¥ç¤ºä¾‹å±•ç¤ºäº†ï¼š
- åŸºæœ¬åŸºå‡†æµ‹è¯•é…ç½®å’Œè¿è¡Œ
- å¤šç§å†…ç½®æµ‹è¯•ç±»å‹çš„ä½¿ç”¨
- åŸºå‡†æµ‹è¯•å¥—ä»¶çš„åˆ›å»ºå’Œæ‰§è¡Œ
- å¤šæ ¼å¼æŠ¥å‘Šç”Ÿæˆ
- æ€§èƒ½åˆ†æå’Œå¯¹æ¯”
- è‡ªå®šä¹‰åŸºå‡†æµ‹è¯•çš„å®ç°

## æ€»ç»“

æ€§èƒ½åŸºå‡†æµ‹è¯•åŠŸèƒ½ä¸ºæ•°æ®åº“æ€§èƒ½è¯„ä¼°å’Œä¼˜åŒ–æä¾›äº†å¼ºå¤§çš„å·¥å…·ã€‚é€šè¿‡ç³»ç»Ÿæ€§çš„æ€§èƒ½æµ‹è¯•ï¼Œå¯ä»¥ï¼š

- **è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ**ï¼šå‘ç°åº”ç”¨ä¸­çš„æ€§èƒ½é—®é¢˜
- **éªŒè¯ä¼˜åŒ–æ•ˆæœ**ï¼šé‡åŒ–ä¼˜åŒ–æªæ–½çš„æ•ˆæœ
- **å»ºç«‹æ€§èƒ½åŸºçº¿**ï¼šä¸ºæŒç»­æ€§èƒ½ç›‘æ§æä¾›å‚è€ƒ
- **æŒ‡å¯¼æ¶æ„å†³ç­–**ï¼šåŸºäºå®é™…æ€§èƒ½æ•°æ®åšå‡ºæŠ€æœ¯é€‰æ‹©

åˆç†ä½¿ç”¨åŸºå‡†æµ‹è¯•åŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡åº”ç”¨çš„æ•°æ®åº“æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚
