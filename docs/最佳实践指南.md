# ygggo_mysql 最佳实践指南

## 概述

本指南提供了使用 ygggo_mysql 库的最佳实践，帮助开发者避免常见陷阱，编写高效、安全的数据库代码。

## 🚨 关键安全原则

### 1. 避免嵌套的 WithConn 调用 - 防止死锁

**❌ 错误示例 - 会导致死锁：**

```go
// 危险！嵌套的 WithConn 调用会导致死锁
err := pool.WithConn(ctx, func(conn1 DatabaseConn) error {
    // 外层连接
    rows, err := conn1.Query(ctx, "SELECT id FROM users")
    if err != nil {
        return err
    }
    defer rows.Close()
    
    for rows.Next() {
        var id int
        rows.Scan(&id)
        
        // ❌ 嵌套调用 WithConn - 死锁风险！
        err := pool.WithConn(ctx, func(conn2 DatabaseConn) error {
            _, err := conn2.Exec(ctx, "UPDATE users SET last_seen = NOW() WHERE id = ?", id)
            return err
        })
        if err != nil {
            return err
        }
    }
    return nil
})
```

**✅ 正确示例 - 使用单个连接：**

```go
// 正确！在同一个连接中完成所有操作
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    rows, err := conn.Query(ctx, "SELECT id FROM users")
    if err != nil {
        return err
    }
    defer rows.Close()
    
    var ids []int
    for rows.Next() {
        var id int
        rows.Scan(&id)
        ids = append(ids, id)
    }
    
    // 在同一个连接中执行更新
    for _, id := range ids {
        _, err := conn.Exec(ctx, "UPDATE users SET last_seen = NOW() WHERE id = ?", id)
        if err != nil {
            return err
        }
    }
    return nil
})
```

**✅ 更好的示例 - 使用批量操作：**

```go
// 最佳！使用批量更新避免循环
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    _, err := conn.Exec(ctx, `
        UPDATE users 
        SET last_seen = NOW() 
        WHERE id IN (SELECT id FROM users WHERE active = 1)
    `)
    return err
})
```

### 2. 死锁的根本原因

- **连接池耗尽**: 嵌套调用会占用多个连接，当连接池满时导致死锁
- **资源竞争**: 外层连接等待内层连接释放，内层连接等待连接池可用
- **事务冲突**: 在事务中嵌套调用可能导致锁等待

## 📋 连接管理最佳实践

### 1. 合理使用 WithConn

```go
// ✅ 好的实践：短时间持有连接
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    // 快速执行数据库操作
    result, err := conn.Exec(ctx, "INSERT INTO users (name) VALUES (?)", name)
    return err
})

// ❌ 避免：长时间持有连接
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    // 避免在连接回调中执行耗时操作
    time.Sleep(10 * time.Second) // 不要这样做！
    result, err := conn.Exec(ctx, "INSERT INTO users (name) VALUES (?)", name)
    return err
})
```

### 2. 优先使用事务

```go
// ✅ 推荐：使用事务确保数据一致性
err := pool.WithinTx(ctx, func(tx DatabaseTx) error {
    // 在事务中执行多个相关操作
    _, err := tx.Exec(ctx, "INSERT INTO orders (user_id, amount) VALUES (?, ?)", userID, amount)
    if err != nil {
        return err
    }
    
    _, err = tx.Exec(ctx, "UPDATE users SET balance = balance - ? WHERE id = ?", amount, userID)
    return err
})
```

### 3. 连接池配置

```go
config := Config{
    Pool: PoolConfig{
        MaxOpen:         25,  // 最大连接数
        MaxIdle:         10,  // 最大空闲连接数
        ConnMaxLifetime: time.Hour,     // 连接最大生命周期
        ConnMaxIdleTime: 30 * time.Minute, // 连接最大空闲时间
    },
}
```

## 🔄 事务处理最佳实践

### 1. 事务边界控制

```go
// ✅ 正确：明确的事务边界
func TransferMoney(pool *Pool, fromID, toID int64, amount decimal.Decimal) error {
    return pool.WithinTx(ctx, func(tx DatabaseTx) error {
        // 检查余额
        var balance decimal.Decimal
        err := tx.QueryRow(ctx, "SELECT balance FROM accounts WHERE id = ?", fromID).Scan(&balance)
        if err != nil {
            return err
        }
        
        if balance.LessThan(amount) {
            return errors.New("insufficient funds")
        }
        
        // 扣款
        _, err = tx.Exec(ctx, "UPDATE accounts SET balance = balance - ? WHERE id = ?", amount, fromID)
        if err != nil {
            return err
        }
        
        // 入账
        _, err = tx.Exec(ctx, "UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, toID)
        return err
    })
}
```

### 2. 事务重试策略

```go
// ✅ 配置重试策略处理死锁
config := Config{
    Retry: RetryPolicy{
        MaxAttempts: 3,
        BaseBackoff: 100 * time.Millisecond,
        MaxBackoff:  time.Second,
        MaxElapsed:  30 * time.Second,
        Jitter:      true,
    },
}
```

## 📊 查询优化最佳实践

### 1. 使用预处理语句缓存

```go
// ✅ 启用语句缓存提高性能
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    conn.EnableStmtCache(100) // 缓存100个预处理语句
    
    // 重复执行的查询会被缓存
    for _, userID := range userIDs {
        _, err := conn.ExecCached(ctx, "UPDATE users SET last_login = NOW() WHERE id = ?", userID)
        if err != nil {
            return err
        }
    }
    return nil
})
```

### 2. 批量操作

```go
// ✅ 使用批量插入提高性能
func BulkInsertUsers(pool *Pool, users []User) error {
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        columns := []string{"name", "email", "created_at"}
        var rows [][]any
        
        for _, user := range users {
            rows = append(rows, []any{user.Name, user.Email, time.Now()})
        }
        
        _, err := conn.BulkInsert(ctx, "users", columns, rows)
        return err
    })
}
```

### 3. 命名参数

```go
// ✅ 使用命名参数提高可读性
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    _, err := conn.NamedExec(ctx, `
        INSERT INTO users (name, email, age, city) 
        VALUES (:name, :email, :age, :city)
    `, map[string]any{
        "name":  "张三",
        "email": "zhangsan@example.com",
        "age":   30,
        "city":  "北京",
    })
    return err
})
```

## 🔍 错误处理最佳实践

### 1. 错误分类处理

```go
func HandleDatabaseError(err error) error {
    if err == nil {
        return nil
    }
    
    // 检查是否为可重试错误
    if IsRetryable(err) {
        log.Warn("Retryable database error", "error", err)
        return err // 让重试机制处理
    }
    
    // 检查具体错误类型
    switch Classify(err) {
    case ErrDeadlock:
        return fmt.Errorf("database deadlock detected: %w", err)
    case ErrTimeout:
        return fmt.Errorf("database operation timeout: %w", err)
    case ErrReadOnly:
        return fmt.Errorf("database is read-only: %w", err)
    default:
        return fmt.Errorf("database error: %w", err)
    }
}
```

### 2. 上下文超时控制

```go
// ✅ 设置合理的超时时间
func QueryWithTimeout(pool *Pool, query string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    return pool.WithConn(ctx, func(conn DatabaseConn) error {
        rows, err := conn.Query(ctx, query)
        if err != nil {
            return err
        }
        defer rows.Close()
        
        // 处理结果...
        return nil
    })
}
```

## 📈 监控和调试最佳实践

### 1. 启用日志记录

```go
// ✅ 启用详细日志记录
pool.EnableLogging(true)
pool.SetSlowQueryThreshold(100 * time.Millisecond)
pool.SetLogger(slog.New(slog.NewJSONHandler(os.Stdout, nil)))
```

### 2. 启用指标监控

```go
// ✅ 启用指标收集
reader := metric.NewManualReader()
provider := metric.NewMeterProvider(metric.WithReader(reader))

pool.EnableMetrics(true)
pool.SetMeterProvider(provider)
```

### 3. 连接泄漏检测

```go
// ✅ 启用连接泄漏检测
pool.EnableLeakDetection(5 * time.Second, func(leak BorrowLeak) {
    log.Error("Connection leak detected", 
        "duration", leak.Duration,
        "stack", leak.Stack)
})
```

## 🧪 测试最佳实践

### 1. 使用 SQLite Mock 进行单元测试

```go
func TestUserService(t *testing.T) {
    ctx := context.Background()
    pool, mock, err := NewMockPool(ctx, Config{})
    require.NoError(t, err)
    defer pool.Close()
    
    // 设置期望
    rows := NewRows([]string{"id", "name"})
    rows = AddRow(rows, 1, "张三")
    mock.ExpectQuery("SELECT id, name FROM users WHERE active = ?").
        WithArgs(true).
        WillReturnRows(rows)
    
    // 执行测试
    service := NewUserService(pool)
    users, err := service.GetActiveUsers(ctx)
    
    // 验证结果
    require.NoError(t, err)
    assert.Len(t, users, 1)
    assert.Equal(t, "张三", users[0].Name)
    
    // 验证期望
    require.NoError(t, mock.ExpectationsWereMet())
}
```

### 2. 集成测试使用真实 SQLite

```go
func TestIntegration(t *testing.T) {
    ctx := context.Background()
    helper, err := NewSQLiteTestHelper(ctx)
    require.NoError(t, err)
    defer helper.Close()
    
    // 设置测试数据
    err = helper.SetupUsersTable(ctx)
    require.NoError(t, err)
    
    // 执行测试...
}
```

## ⚠️ 常见陷阱和避免方法

### 1. 避免在循环中创建连接

```go
// ❌ 错误：在循环中重复获取连接
for _, user := range users {
    pool.WithConn(ctx, func(conn DatabaseConn) error {
        return conn.Exec(ctx, "UPDATE users SET status = ? WHERE id = ?", "active", user.ID)
    })
}

// ✅ 正确：使用单个连接或批量操作
pool.WithConn(ctx, func(conn DatabaseConn) error {
    for _, user := range users {
        err := conn.Exec(ctx, "UPDATE users SET status = ? WHERE id = ?", "active", user.ID)
        if err != nil {
            return err
        }
    }
    return nil
})
```

### 2. 避免忘记关闭资源

```go
// ✅ 始终使用 defer 关闭资源
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    rows, err := conn.Query(ctx, "SELECT * FROM users")
    if err != nil {
        return err
    }
    defer rows.Close() // 重要：确保关闭
    
    // 处理结果...
    return nil
})
```

### 3. 避免 SQL 注入

```go
// ❌ 危险：SQL 注入风险
query := fmt.Sprintf("SELECT * FROM users WHERE name = '%s'", userName)

// ✅ 安全：使用参数化查询
err := pool.WithConn(ctx, func(conn DatabaseConn) error {
    rows, err := conn.Query(ctx, "SELECT * FROM users WHERE name = ?", userName)
    // ...
})
```

## 📚 总结

遵循这些最佳实践可以帮助您：

1. **避免死锁** - 特别是嵌套 WithConn 调用
2. **提高性能** - 通过连接池配置和批量操作
3. **确保数据一致性** - 正确使用事务
4. **简化调试** - 启用日志和监控
5. **编写可靠的测试** - 使用 Mock 和集成测试

记住：**永远不要嵌套 WithConn 调用**，这是避免死锁的最重要原则！
