# ygggo_mysql å®˜æ–¹æ•™ç¨‹

## ğŸ¯ æ•™ç¨‹æ¦‚è¿°

æœ¬æ•™ç¨‹å°†é€šè¿‡å®é™…é¡¹ç›®ç¤ºä¾‹ï¼Œå¸¦ä½ ä»é›¶å¼€å§‹æŒæ¡ ygggo_mysql çš„ä½¿ç”¨ã€‚æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·ç®¡ç†ç³»ç»Ÿï¼Œæ¶µç›–æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## ğŸ“š æ•™ç¨‹ç›®å½•

1. [ç¯å¢ƒå‡†å¤‡](#ç¯å¢ƒå‡†å¤‡)
2. [é¡¹ç›®åˆå§‹åŒ–](#é¡¹ç›®åˆå§‹åŒ–)
3. [åŸºç¡€ CRUD æ“ä½œ](#åŸºç¡€-crud-æ“ä½œ)
4. [äº‹åŠ¡å¤„ç†](#äº‹åŠ¡å¤„ç†)
5. [é«˜çº§æŸ¥è¯¢](#é«˜çº§æŸ¥è¯¢)
6. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
7. [ç›‘æ§å’Œè¿ç»´](#ç›‘æ§å’Œè¿ç»´)
8. [ç”Ÿäº§éƒ¨ç½²](#ç”Ÿäº§éƒ¨ç½²)

## ğŸ›  ç¯å¢ƒå‡†å¤‡

### 1. å®‰è£… MySQL

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install mysql-server

# CentOS/RHEL
sudo yum install mysql-server

# macOS
brew install mysql

# å¯åŠ¨ MySQL æœåŠ¡
sudo systemctl start mysql
```

### 2. åˆ›å»ºæ•°æ®åº“å’Œç”¨æˆ·

```sql
-- è¿æ¥åˆ° MySQL
mysql -u root -p

-- åˆ›å»ºæ•°æ®åº“
CREATE DATABASE tutorial_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- åˆ›å»ºç”¨æˆ·
CREATE USER 'tutorial_user'@'localhost' IDENTIFIED BY 'tutorial_pass';

-- æˆæƒ
GRANT ALL PRIVILEGES ON tutorial_db.* TO 'tutorial_user'@'localhost';
FLUSH PRIVILEGES;
```

### 3. åˆ›å»ºè¡¨ç»“æ„

```sql
USE tutorial_db;

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    age INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- è®¢å•è¡¨
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- è´¦æˆ·è¡¨ï¼ˆç”¨äºæ¼”ç¤ºäº‹åŠ¡ï¼‰
CREATE TABLE accounts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    balance DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

## ğŸš€ é¡¹ç›®åˆå§‹åŒ–

### 1. åˆ›å»º Go é¡¹ç›®

```bash
mkdir ygggo-tutorial
cd ygggo-tutorial
go mod init ygggo-tutorial
```

### 2. å®‰è£…ä¾èµ–

```bash
go get github.com/yggai/ygggo_mysql
```

### 3. åˆ›å»ºåŸºç¡€ç»“æ„

```go
// main.go
package main

import (
    "context"
    "log"
    "time"
    
    ggm "github.com/yggai/ygggo_mysql"
)

// ç”¨æˆ·ç»“æ„ä½“
type User struct {
    ID        int       `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    Age       int       `json:"age" db:"age"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// è®¢å•ç»“æ„ä½“
type Order struct {
    ID          int     `json:"id" db:"id"`
    UserID      int     `json:"user_id" db:"user_id"`
    ProductName string  `json:"product_name" db:"product_name"`
    Amount      float64 `json:"amount" db:"amount"`
    Status      string  `json:"status" db:"status"`
    CreatedAt   time.Time `json:"created_at" db:"created_at"`
}

// è´¦æˆ·ç»“æ„ä½“
type Account struct {
    ID        int     `json:"id" db:"id"`
    UserID    int     `json:"user_id" db:"user_id"`
    Balance   float64 `json:"balance" db:"balance"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}

func main() {
    // æ•°æ®åº“é…ç½®
    config := ggm.Config{
        Host:     "localhost",
        Port:     3306,
        Username: "tutorial_user",
        Password: "tutorial_pass",
        Database: "tutorial_db",
        Pool: ggm.PoolConfig{
            MaxOpen:         25,
            MaxIdle:         10,
            ConnMaxLifetime: 5 * time.Minute,
        },
        SlowQueryThreshold: 100 * time.Millisecond,
    }

    // åˆ›å»ºè¿æ¥æ± 
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("æ•°æ®åº“è¿æ¥å¤±è´¥:", err)
    }
    defer pool.Close()

    log.Println("æ•°æ®åº“è¿æ¥æˆåŠŸ!")

    // è¿è¡Œæ•™ç¨‹ç¤ºä¾‹
    runTutorial(ctx, pool)
}

func runTutorial(ctx context.Context, pool *ggm.Pool) {
    log.Println("å¼€å§‹è¿è¡Œæ•™ç¨‹ç¤ºä¾‹...")
    
    // è¿™é‡Œå°†æ·»åŠ å„ç§ç¤ºä¾‹
}
```

## ğŸ“Š åŸºç¡€ CRUD æ“ä½œ

### 1. åˆ›å»ºç”¨æˆ·æœåŠ¡

```go
// user_service.go
package main

import (
    "context"
    "fmt"
    
    ggm "github.com/yggai/ygggo_mysql"
)

type UserService struct {
    pool *ggm.Pool
}

func NewUserService(pool *ggm.Pool) *UserService {
    return &UserService{pool: pool}
}

// åˆ›å»ºç”¨æˆ·
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx,
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            user.Name, user.Email, user.Age)
        if err != nil {
            return fmt.Errorf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        }
        
        id, err := result.LastInsertId()
        if err != nil {
            return err
        }
        
        user.ID = int(id)
        return nil
    })
}

// æ ¹æ®IDè·å–ç”¨æˆ·
func (s *UserService) GetUserByID(ctx context.Context, id int) (*User, error) {
    var user User
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        row := conn.QueryRow(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users WHERE id = ?",
            id)
        
        return row.Scan(&user.ID, &user.Name, &user.Email, &user.Age, 
            &user.CreatedAt, &user.UpdatedAt)
    })
    
    if err != nil {
        return nil, fmt.Errorf("è·å–ç”¨æˆ·å¤±è´¥: %v", err)
    }
    
    return &user, nil
}

// è·å–æ‰€æœ‰ç”¨æˆ·
func (s *UserService) GetAllUsers(ctx context.Context) ([]*User, error) {
    var users []*User
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        rows, err := conn.Query(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users ORDER BY id")
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.Age,
                &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return err
            }
            users = append(users, &user)
        }
        
        return rows.Err()
    })
    
    if err != nil {
        return nil, fmt.Errorf("è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: %v", err)
    }
    
    return users, nil
}

// æ›´æ–°ç”¨æˆ·
func (s *UserService) UpdateUser(ctx context.Context, user *User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx,
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            user.Name, user.Email, user.Age, user.ID)
        if err != nil {
            return fmt.Errorf("æ›´æ–°ç”¨æˆ·å¤±è´¥: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("ç”¨æˆ·ä¸å­˜åœ¨: ID=%d", user.ID)
        }
        
        return nil
    })
}

// åˆ é™¤ç”¨æˆ·
func (s *UserService) DeleteUser(ctx context.Context, id int) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx, "DELETE FROM users WHERE id = ?", id)
        if err != nil {
            return fmt.Errorf("åˆ é™¤ç”¨æˆ·å¤±è´¥: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("ç”¨æˆ·ä¸å­˜åœ¨: ID=%d", id)
        }
        
        return nil
    })
}

// æ‰¹é‡åˆ›å»ºç”¨æˆ·
func (s *UserService) BatchCreateUsers(ctx context.Context, users []*User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        columns := []string{"name", "email", "age"}
        rows := make([][]any, len(users))
        
        for i, user := range users {
            rows[i] = []any{user.Name, user.Email, user.Age}
        }
        
        _, err := conn.BulkInsert(ctx, "users", columns, rows)
        if err != nil {
            return fmt.Errorf("æ‰¹é‡åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        }
        
        return nil
    })
}
```

### 2. æµ‹è¯• CRUD æ“ä½œ

```go
// åœ¨ main.go çš„ runTutorial å‡½æ•°ä¸­æ·»åŠ 
func runTutorial(ctx context.Context, pool *ggm.Pool) {
    userService := NewUserService(pool)
    
    // 1. åˆ›å»ºç”¨æˆ·
    log.Println("=== åˆ›å»ºç”¨æˆ· ===")
    user := &User{
        Name:  "å¼ ä¸‰",
        Email: "zhangsan@example.com",
        Age:   25,
    }
    
    if err := userService.CreateUser(ctx, user); err != nil {
        log.Printf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    log.Printf("åˆ›å»ºç”¨æˆ·æˆåŠŸ: ID=%d", user.ID)
    
    // 2. è·å–ç”¨æˆ·
    log.Println("=== è·å–ç”¨æˆ· ===")
    fetchedUser, err := userService.GetUserByID(ctx, user.ID)
    if err != nil {
        log.Printf("è·å–ç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    log.Printf("è·å–ç”¨æˆ·æˆåŠŸ: %+v", fetchedUser)
    
    // 3. æ›´æ–°ç”¨æˆ·
    log.Println("=== æ›´æ–°ç”¨æˆ· ===")
    fetchedUser.Age = 26
    fetchedUser.Email = "zhangsan_new@example.com"
    
    if err := userService.UpdateUser(ctx, fetchedUser); err != nil {
        log.Printf("æ›´æ–°ç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    log.Println("æ›´æ–°ç”¨æˆ·æˆåŠŸ")
    
    // 4. æ‰¹é‡åˆ›å»ºç”¨æˆ·
    log.Println("=== æ‰¹é‡åˆ›å»ºç”¨æˆ· ===")
    batchUsers := []*User{
        {Name: "æå››", Email: "lisi@example.com", Age: 30},
        {Name: "ç‹äº”", Email: "wangwu@example.com", Age: 28},
        {Name: "èµµå…­", Email: "zhaoliu@example.com", Age: 35},
    }
    
    if err := userService.BatchCreateUsers(ctx, batchUsers); err != nil {
        log.Printf("æ‰¹é‡åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
        return
    }
    log.Println("æ‰¹é‡åˆ›å»ºç”¨æˆ·æˆåŠŸ")
    
    // 5. è·å–æ‰€æœ‰ç”¨æˆ·
    log.Println("=== è·å–æ‰€æœ‰ç”¨æˆ· ===")
    allUsers, err := userService.GetAllUsers(ctx)
    if err != nil {
        log.Printf("è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥: %v", err)
        return
    }
    
    for _, u := range allUsers {
        log.Printf("ç”¨æˆ·: ID=%d, Name=%s, Email=%s, Age=%d", 
            u.ID, u.Name, u.Email, u.Age)
    }
}
```

## ğŸ’° äº‹åŠ¡å¤„ç†

### 1. åˆ›å»ºè®¢å•æœåŠ¡

```go
// order_service.go
package main

import (
    "context"
    "fmt"
    
    ggm "github.com/yggai/ygggo_mysql"
)

type OrderService struct {
    pool *ggm.Pool
}

func NewOrderService(pool *ggm.Pool) *OrderService {
    return &OrderService{pool: pool}
}

// åˆ›å»ºè®¢å•å¹¶æ‰£é™¤è´¦æˆ·ä½™é¢ï¼ˆäº‹åŠ¡ç¤ºä¾‹ï¼‰
func (s *OrderService) CreateOrderWithPayment(ctx context.Context, userID int, productName string, amount float64) (*Order, error) {
    var order Order
    
    err := s.pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // 1. æ£€æŸ¥ç”¨æˆ·è´¦æˆ·ä½™é¢
        var balance float64
        row := tx.QueryRow(ctx, "SELECT balance FROM accounts WHERE user_id = ?", userID)
        if err := row.Scan(&balance); err != nil {
            return fmt.Errorf("æŸ¥è¯¢è´¦æˆ·ä½™é¢å¤±è´¥: %v", err)
        }
        
        if balance < amount {
            return fmt.Errorf("ä½™é¢ä¸è¶³: å½“å‰ä½™é¢=%.2f, éœ€è¦=%.2f", balance, amount)
        }
        
        // 2. åˆ›å»ºè®¢å•
        result, err := tx.Exec(ctx,
            "INSERT INTO orders (user_id, product_name, amount, status) VALUES (?, ?, ?, 'paid')",
            userID, productName, amount)
        if err != nil {
            return fmt.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %v", err)
        }
        
        orderID, err := result.LastInsertId()
        if err != nil {
            return err
        }
        
        // 3. æ‰£é™¤è´¦æˆ·ä½™é¢
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
            amount, userID)
        if err != nil {
            return fmt.Errorf("æ‰£é™¤ä½™é¢å¤±è´¥: %v", err)
        }
        
        // 4. è®¾ç½®è¿”å›çš„è®¢å•ä¿¡æ¯
        order = Order{
            ID:          int(orderID),
            UserID:      userID,
            ProductName: productName,
            Amount:      amount,
            Status:      "paid",
        }
        
        return nil
    })
    
    if err != nil {
        return nil, err
    }
    
    return &order, nil
}

// è½¬è´¦åŠŸèƒ½ï¼ˆäº‹åŠ¡ç¤ºä¾‹ï¼‰
func (s *OrderService) TransferMoney(ctx context.Context, fromUserID, toUserID int, amount float64) error {
    return s.pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // 1. æ£€æŸ¥è½¬å‡ºè´¦æˆ·ä½™é¢å¹¶æ‰£æ¬¾
        result, err := tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE user_id = ? AND balance >= ?",
            amount, fromUserID, amount)
        if err != nil {
            return fmt.Errorf("æ‰£æ¬¾å¤±è´¥: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("è½¬å‡ºå¤±è´¥: è´¦æˆ·ä¸å­˜åœ¨æˆ–ä½™é¢ä¸è¶³")
        }
        
        // 2. å‘è½¬å…¥è´¦æˆ·åŠ æ¬¾
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
            amount, toUserID)
        if err != nil {
            return fmt.Errorf("åŠ æ¬¾å¤±è´¥: %v", err)
        }
        
        log.Printf("è½¬è´¦æˆåŠŸ: ç”¨æˆ·%d -> ç”¨æˆ·%d, é‡‘é¢=%.2f", fromUserID, toUserID, amount)
        return nil
    })
}
```

### 2. æµ‹è¯•äº‹åŠ¡æ“ä½œ

```go
// åœ¨ runTutorial å‡½æ•°ä¸­æ·»åŠ äº‹åŠ¡æµ‹è¯•
func testTransactions(ctx context.Context, pool *ggm.Pool) {
    orderService := NewOrderService(pool)
    
    // é¦–å…ˆä¸ºç”¨æˆ·åˆ›å»ºè´¦æˆ·
    log.Println("=== åˆå§‹åŒ–è´¦æˆ· ===")
    err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // ä¸ºå‰ä¸¤ä¸ªç”¨æˆ·åˆ›å»ºè´¦æˆ·
        _, err := conn.Exec(ctx, "INSERT INTO accounts (user_id, balance) VALUES (?, ?)", 1, 1000.00)
        if err != nil {
            return err
        }
        _, err = conn.Exec(ctx, "INSERT INTO accounts (user_id, balance) VALUES (?, ?)", 2, 500.00)
        return err
    })
    
    if err != nil {
        log.Printf("åˆå§‹åŒ–è´¦æˆ·å¤±è´¥: %v", err)
        return
    }
    
    // æµ‹è¯•æˆåŠŸçš„è®¢å•åˆ›å»º
    log.Println("=== åˆ›å»ºè®¢å•ï¼ˆæˆåŠŸï¼‰ ===")
    order, err := orderService.CreateOrderWithPayment(ctx, 1, "ç¬”è®°æœ¬ç”µè„‘", 800.00)
    if err != nil {
        log.Printf("åˆ›å»ºè®¢å•å¤±è´¥: %v", err)
    } else {
        log.Printf("åˆ›å»ºè®¢å•æˆåŠŸ: %+v", order)
    }
    
    // æµ‹è¯•å¤±è´¥çš„è®¢å•åˆ›å»ºï¼ˆä½™é¢ä¸è¶³ï¼‰
    log.Println("=== åˆ›å»ºè®¢å•ï¼ˆä½™é¢ä¸è¶³ï¼‰ ===")
    _, err = orderService.CreateOrderWithPayment(ctx, 1, "è±ªåæ±½è½¦", 50000.00)
    if err != nil {
        log.Printf("é¢„æœŸçš„å¤±è´¥: %v", err)
    }
    
    // æµ‹è¯•è½¬è´¦
    log.Println("=== è½¬è´¦æµ‹è¯• ===")
    err = orderService.TransferMoney(ctx, 2, 1, 100.00)
    if err != nil {
        log.Printf("è½¬è´¦å¤±è´¥: %v", err)
    } else {
        log.Println("è½¬è´¦æˆåŠŸ")
    }
}
```

## ğŸ” é«˜çº§æŸ¥è¯¢

### 1. å¤æ‚æŸ¥è¯¢ç¤ºä¾‹

```go
// æŸ¥è¯¢ç”¨æˆ·åŠå…¶è®¢å•ç»Ÿè®¡
func (s *UserService) GetUsersWithOrderStats(ctx context.Context) ([]map[string]interface{}, error) {
    var results []map[string]interface{}
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        query := `
            SELECT 
                u.id,
                u.name,
                u.email,
                COUNT(o.id) as order_count,
                COALESCE(SUM(o.amount), 0) as total_amount,
                COALESCE(a.balance, 0) as balance
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            LEFT JOIN accounts a ON u.id = a.user_id
            GROUP BY u.id, u.name, u.email, a.balance
            ORDER BY total_amount DESC
        `
        
        rows, err := conn.Query(ctx, query)
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var id int
            var name, email string
            var orderCount int
            var totalAmount, balance float64
            
            err := rows.Scan(&id, &name, &email, &orderCount, &totalAmount, &balance)
            if err != nil {
                return err
            }
            
            results = append(results, map[string]interface{}{
                "id":           id,
                "name":         name,
                "email":        email,
                "order_count":  orderCount,
                "total_amount": totalAmount,
                "balance":      balance,
            })
        }
        
        return rows.Err()
    })
    
    return results, err
}

// åˆ†é¡µæŸ¥è¯¢
func (s *UserService) GetUsersPaginated(ctx context.Context, page, pageSize int) ([]*User, int, error) {
    var users []*User
    var total int
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // è·å–æ€»æ•°
        row := conn.QueryRow(ctx, "SELECT COUNT(*) FROM users")
        if err := row.Scan(&total); err != nil {
            return err
        }
        
        // è·å–åˆ†é¡µæ•°æ®
        offset := (page - 1) * pageSize
        rows, err := conn.Query(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users ORDER BY id LIMIT ? OFFSET ?",
            pageSize, offset)
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.Age,
                &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return err
            }
            users = append(users, &user)
        }
        
        return rows.Err()
    })
    
    return users, total, err
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–å®è·µ

### 1. é¢„ç¼–è¯‘è¯­å¥ç¼“å­˜

```go
func (s *UserService) BatchUpdateUsersWithCache(ctx context.Context, users []*User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // å¯ç”¨è¯­å¥ç¼“å­˜
        conn.EnableStmtCache(10)
        
        // æ‰¹é‡æ›´æ–°ï¼Œä¼šè‡ªåŠ¨ä½¿ç”¨ç¼“å­˜çš„é¢„ç¼–è¯‘è¯­å¥
        for _, user := range users {
            _, err := conn.ExecCached(ctx,
                "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
                user.Name, user.Email, user.Age, user.ID)
            if err != nil {
                return err
            }
        }
        
        return nil
    })
}
```

### 2. æµå¼å¤„ç†å¤§æ•°æ®

```go
func (s *UserService) ProcessLargeDataset(ctx context.Context) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        return conn.QueryStream(ctx,
            "SELECT id, name, email FROM users",
            func(row []any) error {
                id := row[0].(int64)
                name := row[1].(string)
                email := row[2].(string)
                
                // å¤„ç†æ¯ä¸€è¡Œæ•°æ®
                log.Printf("å¤„ç†ç”¨æˆ·: ID=%d, Name=%s, Email=%s", id, name, email)
                
                // è¿™é‡Œå¯ä»¥è¿›è¡Œå¤æ‚çš„æ•°æ®å¤„ç†
                return processUserData(id, name, email)
            })
    })
}

func processUserData(id int64, name, email string) error {
    // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
    time.Sleep(10 * time.Millisecond)
    return nil
}
```

## ğŸ“Š ç›‘æ§å’Œè¿ç»´

### 1. å¥åº·æ£€æŸ¥

```go
func setupHealthCheck(pool *ggm.Pool) {
    // è®¾ç½®è¿æ¥æ³„æ¼æ£€æµ‹
    pool.SetBorrowWarnThreshold(30 * time.Second)
    pool.SetLeakHandler(func(leak ggm.BorrowLeak) {
        log.Printf("è­¦å‘Š: è¿æ¥æŒæœ‰æ—¶é—´è¿‡é•¿ %v", leak.HeldFor)
    })
    
    // å®šæœŸå¥åº·æ£€æŸ¥
    go func() {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for range ticker.C {
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            
            if err := pool.Ping(ctx); err != nil {
                log.Printf("å¥åº·æ£€æŸ¥å¤±è´¥: %v", err)
            } else {
                log.Println("å¥åº·æ£€æŸ¥é€šè¿‡")
            }
            
            cancel()
        }
    }()
}
```

### 2. æ€§èƒ½ç›‘æ§

```go
func monitorPerformance(pool *ggm.Pool) {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := pool.Stats()
            log.Printf("è¿æ¥æ± çŠ¶æ€: æ‰“å¼€=%d, ä½¿ç”¨ä¸­=%d, ç©ºé—²=%d",
                stats.OpenConnections, stats.InUse, stats.Idle)
        }
    }()
}
```

## ğŸš€ ç”Ÿäº§éƒ¨ç½²

### 1. ç”Ÿäº§ç¯å¢ƒé…ç½®

```go
func createProductionConfig() ggm.Config {
    return ggm.Config{
        Host:     getEnv("DB_HOST", "localhost"),
        Port:     getEnvInt("DB_PORT", 3306),
        Username: getEnv("DB_USERNAME", ""),
        Password: getEnv("DB_PASSWORD", ""),
        Database: getEnv("DB_DATABASE", ""),
        
        Params: map[string]string{
            "charset":   "utf8mb4",
            "parseTime": "true",
            "loc":       "UTC",
            "tls":       "true", // å¯ç”¨ TLS
        },
        
        Pool: ggm.PoolConfig{
            MaxOpen:         50,
            MaxIdle:         25,
            ConnMaxLifetime: 10 * time.Minute,
            ConnMaxIdleTime: 5 * time.Minute,
        },
        
        SlowQueryThreshold: 200 * time.Millisecond,
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

### 2. ä¼˜é›…å…³é—­

```go
func main() {
    config := createProductionConfig()
    
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("æ•°æ®åº“è¿æ¥å¤±è´¥:", err)
    }
    
    // è®¾ç½®ä¼˜é›…å…³é—­
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-c
        log.Println("æ­£åœ¨å…³é—­æ•°æ®åº“è¿æ¥...")
        pool.Close()
        log.Println("æ•°æ®åº“è¿æ¥å·²å…³é—­")
        os.Exit(0)
    }()
    
    // å¯åŠ¨åº”ç”¨
    runApplication(pool)
}
```

## ğŸ‰ æ€»ç»“

é€šè¿‡æœ¬æ•™ç¨‹ï¼Œä½ å·²ç»å­¦ä¼šäº†ï¼š

1. âœ… ç¯å¢ƒæ­å»ºå’Œé¡¹ç›®åˆå§‹åŒ–
2. âœ… åŸºç¡€ CRUD æ“ä½œ
3. âœ… äº‹åŠ¡å¤„ç†å’Œé”™è¯¯å¤„ç†
4. âœ… é«˜çº§æŸ¥è¯¢å’Œåˆ†é¡µ
5. âœ… æ€§èƒ½ä¼˜åŒ–æŠ€å·§
6. âœ… ç›‘æ§å’Œè¿ç»´å®è·µ
7. âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

### ä¸‹ä¸€æ­¥å­¦ä¹ 

- æ·±å…¥å­¦ä¹  [API æ–‡æ¡£](./APIæ–‡æ¡£.md)
- æŸ¥çœ‹æ›´å¤š [ä½¿ç”¨æ‰‹å†Œ](./ä½¿ç”¨æ‰‹å†Œ.md)
- æ¢ç´¢ [examples/](../examples/) ç›®å½•ä¸­çš„ç¤ºä¾‹
- å‚ä¸å¼€æºè´¡çŒ®

---

**æ­å–œä½ å®Œæˆäº† ygggo_mysql å®˜æ–¹æ•™ç¨‹ï¼ç°åœ¨ä½ å¯ä»¥åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨è¿™ä¸ªå¼ºå¤§çš„æ•°æ®åº“åº“äº†ã€‚**
