# ygggo_mysql 官方教程

## 🎯 教程概述

本教程将通过实际项目示例，带你从零开始掌握 ygggo_mysql 的使用。我们将构建一个完整的用户管理系统，涵盖所有核心功能。

## 📚 教程目录

1. [环境准备](#环境准备)
2. [项目初始化](#项目初始化)
3. [基础 CRUD 操作](#基础-crud-操作)
4. [事务处理](#事务处理)
5. [高级查询](#高级查询)
6. [性能优化](#性能优化)
7. [监控和运维](#监控和运维)
8. [生产部署](#生产部署)

## 🛠 环境准备

### 1. 安装 MySQL

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install mysql-server

# CentOS/RHEL
sudo yum install mysql-server

# macOS
brew install mysql

# 启动 MySQL 服务
sudo systemctl start mysql
```

### 2. 创建数据库和用户

```sql
-- 连接到 MySQL
mysql -u root -p

-- 创建数据库
CREATE DATABASE tutorial_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建用户
CREATE USER 'tutorial_user'@'localhost' IDENTIFIED BY 'tutorial_pass';

-- 授权
GRANT ALL PRIVILEGES ON tutorial_db.* TO 'tutorial_user'@'localhost';
FLUSH PRIVILEGES;
```

### 3. 创建表结构

```sql
USE tutorial_db;

-- 用户表
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    age INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 订单表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'completed', 'cancelled') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 账户表（用于演示事务）
CREATE TABLE accounts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    balance DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

## 🚀 项目初始化

### 1. 创建 Go 项目

```bash
mkdir ygggo-tutorial
cd ygggo-tutorial
go mod init ygggo-tutorial
```

### 2. 安装依赖

```bash
go get github.com/yggai/ygggo_mysql
```

### 3. 创建基础结构

```go
// main.go
package main

import (
    "context"
    "log"
    "time"
    
    ggm "github.com/yggai/ygggo_mysql"
)

// 用户结构体
type User struct {
    ID        int       `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    Age       int       `json:"age" db:"age"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// 订单结构体
type Order struct {
    ID          int     `json:"id" db:"id"`
    UserID      int     `json:"user_id" db:"user_id"`
    ProductName string  `json:"product_name" db:"product_name"`
    Amount      float64 `json:"amount" db:"amount"`
    Status      string  `json:"status" db:"status"`
    CreatedAt   time.Time `json:"created_at" db:"created_at"`
}

// 账户结构体
type Account struct {
    ID        int     `json:"id" db:"id"`
    UserID    int     `json:"user_id" db:"user_id"`
    Balance   float64 `json:"balance" db:"balance"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}

func main() {
    // 数据库配置
    config := ggm.Config{
        Host:     "localhost",
        Port:     3306,
        Username: "tutorial_user",
        Password: "tutorial_pass",
        Database: "tutorial_db",
        Pool: ggm.PoolConfig{
            MaxOpen:         25,
            MaxIdle:         10,
            ConnMaxLifetime: 5 * time.Minute,
        },
        SlowQueryThreshold: 100 * time.Millisecond,
    }

    // 创建连接池
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("数据库连接失败:", err)
    }
    defer pool.Close()

    log.Println("数据库连接成功!")

    // 运行教程示例
    runTutorial(ctx, pool)
}

func runTutorial(ctx context.Context, pool *ggm.Pool) {
    log.Println("开始运行教程示例...")
    
    // 这里将添加各种示例
}
```

## 📊 基础 CRUD 操作

### 1. 创建用户服务

```go
// user_service.go
package main

import (
    "context"
    "fmt"
    
    ggm "github.com/yggai/ygggo_mysql"
)

type UserService struct {
    pool *ggm.Pool
}

func NewUserService(pool *ggm.Pool) *UserService {
    return &UserService{pool: pool}
}

// 创建用户
func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx,
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            user.Name, user.Email, user.Age)
        if err != nil {
            return fmt.Errorf("创建用户失败: %v", err)
        }
        
        id, err := result.LastInsertId()
        if err != nil {
            return err
        }
        
        user.ID = int(id)
        return nil
    })
}

// 根据ID获取用户
func (s *UserService) GetUserByID(ctx context.Context, id int) (*User, error) {
    var user User
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        row := conn.QueryRow(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users WHERE id = ?",
            id)
        
        return row.Scan(&user.ID, &user.Name, &user.Email, &user.Age, 
            &user.CreatedAt, &user.UpdatedAt)
    })
    
    if err != nil {
        return nil, fmt.Errorf("获取用户失败: %v", err)
    }
    
    return &user, nil
}

// 获取所有用户
func (s *UserService) GetAllUsers(ctx context.Context) ([]*User, error) {
    var users []*User
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        rows, err := conn.Query(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users ORDER BY id")
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.Age,
                &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return err
            }
            users = append(users, &user)
        }
        
        return rows.Err()
    })
    
    if err != nil {
        return nil, fmt.Errorf("获取用户列表失败: %v", err)
    }
    
    return users, nil
}

// 更新用户
func (s *UserService) UpdateUser(ctx context.Context, user *User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx,
            "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
            user.Name, user.Email, user.Age, user.ID)
        if err != nil {
            return fmt.Errorf("更新用户失败: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("用户不存在: ID=%d", user.ID)
        }
        
        return nil
    })
}

// 删除用户
func (s *UserService) DeleteUser(ctx context.Context, id int) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        result, err := conn.Exec(ctx, "DELETE FROM users WHERE id = ?", id)
        if err != nil {
            return fmt.Errorf("删除用户失败: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("用户不存在: ID=%d", id)
        }
        
        return nil
    })
}

// 批量创建用户
func (s *UserService) BatchCreateUsers(ctx context.Context, users []*User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        columns := []string{"name", "email", "age"}
        rows := make([][]any, len(users))
        
        for i, user := range users {
            rows[i] = []any{user.Name, user.Email, user.Age}
        }
        
        _, err := conn.BulkInsert(ctx, "users", columns, rows)
        if err != nil {
            return fmt.Errorf("批量创建用户失败: %v", err)
        }
        
        return nil
    })
}
```

### 2. 测试 CRUD 操作

```go
// 在 main.go 的 runTutorial 函数中添加
func runTutorial(ctx context.Context, pool *ggm.Pool) {
    userService := NewUserService(pool)
    
    // 1. 创建用户
    log.Println("=== 创建用户 ===")
    user := &User{
        Name:  "张三",
        Email: "zhangsan@example.com",
        Age:   25,
    }
    
    if err := userService.CreateUser(ctx, user); err != nil {
        log.Printf("创建用户失败: %v", err)
        return
    }
    log.Printf("创建用户成功: ID=%d", user.ID)
    
    // 2. 获取用户
    log.Println("=== 获取用户 ===")
    fetchedUser, err := userService.GetUserByID(ctx, user.ID)
    if err != nil {
        log.Printf("获取用户失败: %v", err)
        return
    }
    log.Printf("获取用户成功: %+v", fetchedUser)
    
    // 3. 更新用户
    log.Println("=== 更新用户 ===")
    fetchedUser.Age = 26
    fetchedUser.Email = "zhangsan_new@example.com"
    
    if err := userService.UpdateUser(ctx, fetchedUser); err != nil {
        log.Printf("更新用户失败: %v", err)
        return
    }
    log.Println("更新用户成功")
    
    // 4. 批量创建用户
    log.Println("=== 批量创建用户 ===")
    batchUsers := []*User{
        {Name: "李四", Email: "lisi@example.com", Age: 30},
        {Name: "王五", Email: "wangwu@example.com", Age: 28},
        {Name: "赵六", Email: "zhaoliu@example.com", Age: 35},
    }
    
    if err := userService.BatchCreateUsers(ctx, batchUsers); err != nil {
        log.Printf("批量创建用户失败: %v", err)
        return
    }
    log.Println("批量创建用户成功")
    
    // 5. 获取所有用户
    log.Println("=== 获取所有用户 ===")
    allUsers, err := userService.GetAllUsers(ctx)
    if err != nil {
        log.Printf("获取用户列表失败: %v", err)
        return
    }
    
    for _, u := range allUsers {
        log.Printf("用户: ID=%d, Name=%s, Email=%s, Age=%d", 
            u.ID, u.Name, u.Email, u.Age)
    }
}
```

## 💰 事务处理

### 1. 创建订单服务

```go
// order_service.go
package main

import (
    "context"
    "fmt"
    
    ggm "github.com/yggai/ygggo_mysql"
)

type OrderService struct {
    pool *ggm.Pool
}

func NewOrderService(pool *ggm.Pool) *OrderService {
    return &OrderService{pool: pool}
}

// 创建订单并扣除账户余额（事务示例）
func (s *OrderService) CreateOrderWithPayment(ctx context.Context, userID int, productName string, amount float64) (*Order, error) {
    var order Order
    
    err := s.pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // 1. 检查用户账户余额
        var balance float64
        row := tx.QueryRow(ctx, "SELECT balance FROM accounts WHERE user_id = ?", userID)
        if err := row.Scan(&balance); err != nil {
            return fmt.Errorf("查询账户余额失败: %v", err)
        }
        
        if balance < amount {
            return fmt.Errorf("余额不足: 当前余额=%.2f, 需要=%.2f", balance, amount)
        }
        
        // 2. 创建订单
        result, err := tx.Exec(ctx,
            "INSERT INTO orders (user_id, product_name, amount, status) VALUES (?, ?, ?, 'paid')",
            userID, productName, amount)
        if err != nil {
            return fmt.Errorf("创建订单失败: %v", err)
        }
        
        orderID, err := result.LastInsertId()
        if err != nil {
            return err
        }
        
        // 3. 扣除账户余额
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE user_id = ?",
            amount, userID)
        if err != nil {
            return fmt.Errorf("扣除余额失败: %v", err)
        }
        
        // 4. 设置返回的订单信息
        order = Order{
            ID:          int(orderID),
            UserID:      userID,
            ProductName: productName,
            Amount:      amount,
            Status:      "paid",
        }
        
        return nil
    })
    
    if err != nil {
        return nil, err
    }
    
    return &order, nil
}

// 转账功能（事务示例）
func (s *OrderService) TransferMoney(ctx context.Context, fromUserID, toUserID int, amount float64) error {
    return s.pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // 1. 检查转出账户余额并扣款
        result, err := tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE user_id = ? AND balance >= ?",
            amount, fromUserID, amount)
        if err != nil {
            return fmt.Errorf("扣款失败: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("转出失败: 账户不存在或余额不足")
        }
        
        // 2. 向转入账户加款
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance + ? WHERE user_id = ?",
            amount, toUserID)
        if err != nil {
            return fmt.Errorf("加款失败: %v", err)
        }
        
        log.Printf("转账成功: 用户%d -> 用户%d, 金额=%.2f", fromUserID, toUserID, amount)
        return nil
    })
}
```

### 2. 测试事务操作

```go
// 在 runTutorial 函数中添加事务测试
func testTransactions(ctx context.Context, pool *ggm.Pool) {
    orderService := NewOrderService(pool)
    
    // 首先为用户创建账户
    log.Println("=== 初始化账户 ===")
    err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // 为前两个用户创建账户
        _, err := conn.Exec(ctx, "INSERT INTO accounts (user_id, balance) VALUES (?, ?)", 1, 1000.00)
        if err != nil {
            return err
        }
        _, err = conn.Exec(ctx, "INSERT INTO accounts (user_id, balance) VALUES (?, ?)", 2, 500.00)
        return err
    })
    
    if err != nil {
        log.Printf("初始化账户失败: %v", err)
        return
    }
    
    // 测试成功的订单创建
    log.Println("=== 创建订单（成功） ===")
    order, err := orderService.CreateOrderWithPayment(ctx, 1, "笔记本电脑", 800.00)
    if err != nil {
        log.Printf("创建订单失败: %v", err)
    } else {
        log.Printf("创建订单成功: %+v", order)
    }
    
    // 测试失败的订单创建（余额不足）
    log.Println("=== 创建订单（余额不足） ===")
    _, err = orderService.CreateOrderWithPayment(ctx, 1, "豪华汽车", 50000.00)
    if err != nil {
        log.Printf("预期的失败: %v", err)
    }
    
    // 测试转账
    log.Println("=== 转账测试 ===")
    err = orderService.TransferMoney(ctx, 2, 1, 100.00)
    if err != nil {
        log.Printf("转账失败: %v", err)
    } else {
        log.Println("转账成功")
    }
}
```

## 🔍 高级查询

### 1. 复杂查询示例

```go
// 查询用户及其订单统计
func (s *UserService) GetUsersWithOrderStats(ctx context.Context) ([]map[string]interface{}, error) {
    var results []map[string]interface{}
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        query := `
            SELECT 
                u.id,
                u.name,
                u.email,
                COUNT(o.id) as order_count,
                COALESCE(SUM(o.amount), 0) as total_amount,
                COALESCE(a.balance, 0) as balance
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            LEFT JOIN accounts a ON u.id = a.user_id
            GROUP BY u.id, u.name, u.email, a.balance
            ORDER BY total_amount DESC
        `
        
        rows, err := conn.Query(ctx, query)
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var id int
            var name, email string
            var orderCount int
            var totalAmount, balance float64
            
            err := rows.Scan(&id, &name, &email, &orderCount, &totalAmount, &balance)
            if err != nil {
                return err
            }
            
            results = append(results, map[string]interface{}{
                "id":           id,
                "name":         name,
                "email":        email,
                "order_count":  orderCount,
                "total_amount": totalAmount,
                "balance":      balance,
            })
        }
        
        return rows.Err()
    })
    
    return results, err
}

// 分页查询
func (s *UserService) GetUsersPaginated(ctx context.Context, page, pageSize int) ([]*User, int, error) {
    var users []*User
    var total int
    
    err := s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // 获取总数
        row := conn.QueryRow(ctx, "SELECT COUNT(*) FROM users")
        if err := row.Scan(&total); err != nil {
            return err
        }
        
        // 获取分页数据
        offset := (page - 1) * pageSize
        rows, err := conn.Query(ctx,
            "SELECT id, name, email, age, created_at, updated_at FROM users ORDER BY id LIMIT ? OFFSET ?",
            pageSize, offset)
        if err != nil {
            return err
        }
        defer rows.Close()
        
        for rows.Next() {
            var user User
            err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.Age,
                &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return err
            }
            users = append(users, &user)
        }
        
        return rows.Err()
    })
    
    return users, total, err
}
```

## ⚡ 性能优化实践

### 1. 预编译语句缓存

```go
func (s *UserService) BatchUpdateUsersWithCache(ctx context.Context, users []*User) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        // 启用语句缓存
        conn.EnableStmtCache(10)
        
        // 批量更新，会自动使用缓存的预编译语句
        for _, user := range users {
            _, err := conn.ExecCached(ctx,
                "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?",
                user.Name, user.Email, user.Age, user.ID)
            if err != nil {
                return err
            }
        }
        
        return nil
    })
}
```

### 2. 流式处理大数据

```go
func (s *UserService) ProcessLargeDataset(ctx context.Context) error {
    return s.pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        return conn.QueryStream(ctx,
            "SELECT id, name, email FROM users",
            func(row []any) error {
                id := row[0].(int64)
                name := row[1].(string)
                email := row[2].(string)
                
                // 处理每一行数据
                log.Printf("处理用户: ID=%d, Name=%s, Email=%s", id, name, email)
                
                // 这里可以进行复杂的数据处理
                return processUserData(id, name, email)
            })
    })
}

func processUserData(id int64, name, email string) error {
    // 模拟数据处理
    time.Sleep(10 * time.Millisecond)
    return nil
}
```

## 📊 监控和运维

### 1. 健康检查

```go
func setupHealthCheck(pool *ggm.Pool) {
    // 设置连接泄漏检测
    pool.SetBorrowWarnThreshold(30 * time.Second)
    pool.SetLeakHandler(func(leak ggm.BorrowLeak) {
        log.Printf("警告: 连接持有时间过长 %v", leak.HeldFor)
    })
    
    // 定期健康检查
    go func() {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for range ticker.C {
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
            
            if err := pool.Ping(ctx); err != nil {
                log.Printf("健康检查失败: %v", err)
            } else {
                log.Println("健康检查通过")
            }
            
            cancel()
        }
    }()
}
```

### 2. 性能监控

```go
func monitorPerformance(pool *ggm.Pool) {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := pool.Stats()
            log.Printf("连接池状态: 打开=%d, 使用中=%d, 空闲=%d",
                stats.OpenConnections, stats.InUse, stats.Idle)
        }
    }()
}
```

## 🚀 生产部署

### 1. 生产环境配置

```go
func createProductionConfig() ggm.Config {
    return ggm.Config{
        Host:     getEnv("DB_HOST", "localhost"),
        Port:     getEnvInt("DB_PORT", 3306),
        Username: getEnv("DB_USERNAME", ""),
        Password: getEnv("DB_PASSWORD", ""),
        Database: getEnv("DB_DATABASE", ""),
        
        Params: map[string]string{
            "charset":   "utf8mb4",
            "parseTime": "true",
            "loc":       "UTC",
            "tls":       "true", // 启用 TLS
        },
        
        Pool: ggm.PoolConfig{
            MaxOpen:         50,
            MaxIdle:         25,
            ConnMaxLifetime: 10 * time.Minute,
            ConnMaxIdleTime: 5 * time.Minute,
        },
        
        SlowQueryThreshold: 200 * time.Millisecond,
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

### 2. 优雅关闭

```go
func main() {
    config := createProductionConfig()
    
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("数据库连接失败:", err)
    }
    
    // 设置优雅关闭
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        <-c
        log.Println("正在关闭数据库连接...")
        pool.Close()
        log.Println("数据库连接已关闭")
        os.Exit(0)
    }()
    
    // 启动应用
    runApplication(pool)
}
```

## 🎉 总结

通过本教程，你已经学会了：

1. ✅ 环境搭建和项目初始化
2. ✅ 基础 CRUD 操作
3. ✅ 事务处理和错误处理
4. ✅ 高级查询和分页
5. ✅ 性能优化技巧
6. ✅ 监控和运维实践
7. ✅ 生产环境部署

### 下一步学习

- 深入学习 [API 文档](./API文档.md)
- 查看更多 [使用手册](./使用手册.md)
- 探索 [examples/](../examples/) 目录中的示例
- 参与开源贡献

---

**恭喜你完成了 ygggo_mysql 官方教程！现在你可以在实际项目中使用这个强大的数据库库了。**
