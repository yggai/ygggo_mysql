# ygggo_mysql 使用手册

## 📖 目录

1. [快速开始](#快速开始)
2. [安装配置](#安装配置)
3. [基础操作](#基础操作)
4. [高级功能](#高级功能)
5. [性能优化](#性能优化)
6. [监控运维](#监控运维)
7. [故障排除](#故障排除)
8. [最佳实践](#最佳实践)

## 🚀 快速开始

### 安装

```bash
go get github.com/yggai/ygggo_mysql
```

### 最简示例

```go
package main

import (
    "context"
    "log"
    ggm "github.com/yggai/ygggo_mysql"
)

func main() {
    // 配置数据库连接
    config := ggm.Config{
        Host:     "localhost",
        Port:     3306,
        Username: "root",
        Password: "password",
        Database: "testdb",
    }

    // 创建连接池
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("连接失败:", err)
    }
    defer pool.Close()

    // 执行查询
    err = pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        rows, err := conn.Query(ctx, "SELECT id, name FROM users LIMIT 10")
        if err != nil {
            return err
        }
        defer rows.Close()

        for rows.Next() {
            var id int
            var name string
            if err := rows.Scan(&id, &name); err != nil {
                return err
            }
            log.Printf("用户: ID=%d, Name=%s", id, name)
        }
        return rows.Err()
    })

    if err != nil {
        log.Printf("查询失败: %v", err)
    }
}
```

## ⚙️ 安装配置

### 环境要求

- Go 1.19+
- MySQL 5.7+ 或 8.0+
- 网络连接到 MySQL 服务器

### 依赖安装

```bash
# 安装主库
go get github.com/yggai/ygggo_mysql

# 如果需要 MySQL 驱动（通常会自动安装）
go get github.com/go-sql-driver/mysql
```

### 配置方式

#### 1. 程序化配置

```go
config := ggm.Config{
    // 基础连接配置
    Host:     "localhost",
    Port:     3306,
    Username: "myuser",
    Password: "mypassword",
    Database: "mydb",
    
    // 连接参数
    Params: map[string]string{
        "charset":   "utf8mb4",
        "parseTime": "true",
        "loc":       "Local",
    },
    
    // 连接池配置
    Pool: ggm.PoolConfig{
        MaxOpen:         25,
        MaxIdle:         10,
        ConnMaxLifetime: 5 * time.Minute,
        ConnMaxIdleTime: 2 * time.Minute,
    },
    
    // 性能配置
    SlowQueryThreshold: 100 * time.Millisecond,
}
```

#### 2. 环境变量配置

```bash
export YGGGO_MYSQL_HOST=localhost
export YGGGO_MYSQL_PORT=3306
export YGGGO_MYSQL_USERNAME=myuser
export YGGGO_MYSQL_PASSWORD=mypassword
export YGGGO_MYSQL_DATABASE=mydb
```

#### 3. DSN 配置

```go
config := ggm.Config{
    DSN: "user:password@tcp(localhost:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local",
}
```

## 📊 基础操作

### 查询操作

#### 单行查询

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    var user struct {
        ID   int    `db:"id"`
        Name string `db:"name"`
        Age  int    `db:"age"`
    }
    
    row := conn.QueryRow(ctx, "SELECT id, name, age FROM users WHERE id = ?", 1)
    err := row.Scan(&user.ID, &user.Name, &user.Age)
    if err != nil {
        return err
    }
    
    log.Printf("用户信息: %+v", user)
    return nil
})
```

#### 多行查询

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    rows, err := conn.Query(ctx, "SELECT id, name, age FROM users WHERE age > ?", 18)
    if err != nil {
        return err
    }
    defer rows.Close()

    var users []struct {
        ID   int
        Name string
        Age  int
    }

    for rows.Next() {
        var user struct {
            ID   int
            Name string
            Age  int
        }
        if err := rows.Scan(&user.ID, &user.Name, &user.Age); err != nil {
            return err
        }
        users = append(users, user)
    }

    log.Printf("找到 %d 个用户", len(users))
    return rows.Err()
})
```

### 插入操作

#### 单条插入

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx, 
        "INSERT INTO users (name, age, email) VALUES (?, ?, ?)",
        "张三", 25, "zhangsan@example.com")
    if err != nil {
        return err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    log.Printf("插入成功，新用户ID: %d", id)
    return nil
})
```

#### 批量插入

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    columns := []string{"name", "age", "email"}
    rows := [][]any{
        {"李四", 30, "lisi@example.com"},
        {"王五", 28, "wangwu@example.com"},
        {"赵六", 35, "zhaoliu@example.com"},
    }
    
    result, err := conn.BulkInsert(ctx, "users", columns, rows)
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("批量插入成功，影响行数: %d", affected)
    return nil
})
```

### 更新操作

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx,
        "UPDATE users SET age = ?, email = ? WHERE name = ?",
        26, "zhangsan_new@example.com", "张三")
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("更新成功，影响行数: %d", affected)
    return nil
})
```

### 删除操作

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx, "DELETE FROM users WHERE age < ?", 18)
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("删除成功，影响行数: %d", affected)
    return nil
})
```

## 🔄 事务操作

### 基本事务

```go
err := pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
    // 第一个操作
    _, err := tx.Exec(ctx, "INSERT INTO orders (user_id, amount) VALUES (?, ?)", 1, 100.00)
    if err != nil {
        return err // 自动回滚
    }
    
    // 第二个操作
    _, err = tx.Exec(ctx, "UPDATE users SET balance = balance - ? WHERE id = ?", 100.00, 1)
    if err != nil {
        return err // 自动回滚
    }
    
    return nil // 自动提交
})

if err != nil {
    log.Printf("事务失败: %v", err)
} else {
    log.Println("事务成功提交")
}
```

### 转账示例

```go
func transferMoney(pool *ggm.Pool, fromID, toID int, amount float64) error {
    return pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // 检查并扣除源账户余额
        result, err := tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE id = ? AND balance >= ?",
            amount, fromID, amount)
        if err != nil {
            return fmt.Errorf("扣款失败: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("余额不足或账户不存在")
        }
        
        // 增加目标账户余额
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance + ? WHERE id = ?",
            amount, toID)
        if err != nil {
            return fmt.Errorf("加款失败: %v", err)
        }
        
        // 记录转账日志
        _, err = tx.Exec(ctx,
            "INSERT INTO transfer_logs (from_id, to_id, amount, created_at) VALUES (?, ?, ?, NOW())",
            fromID, toID, amount)
        if err != nil {
            return fmt.Errorf("记录日志失败: %v", err)
        }
        
        return nil
    })
}
```

## 🚀 高级功能

### 预编译语句缓存

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    // 启用语句缓存
    conn.EnableStmtCache(100)
    
    // 重复执行的查询会自动使用缓存
    for i := 0; i < 1000; i++ {
        _, err := conn.ExecCached(ctx,
            "INSERT INTO logs (level, message, created_at) VALUES (?, ?, NOW())",
            "INFO", fmt.Sprintf("处理任务 %d", i))
        if err != nil {
            return err
        }
    }
    
    return nil
})
```

### 命名参数查询

```go
type User struct {
    Name  string `db:"name"`
    Age   int    `db:"age"`
    Email string `db:"email"`
}

err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    user := User{
        Name:  "张三",
        Age:   25,
        Email: "zhangsan@example.com",
    }
    
    _, err := conn.NamedExec(ctx,
        "INSERT INTO users (name, age, email) VALUES (:name, :age, :email)",
        user)
    return err
})
```

### 流式查询

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    return conn.QueryStream(ctx,
        "SELECT id, name, data FROM large_table",
        func(row []any) error {
            id := row[0].(int64)
            name := row[1].(string)
            data := row[2].([]byte)
            
            // 处理每一行数据
            log.Printf("处理记录: ID=%d, Name=%s, DataSize=%d", id, name, len(data))
            
            // 可以在这里进行复杂的数据处理
            return processData(id, name, data)
        })
})
```

### 连接泄漏检测

```go
// 设置连接持有时间警告阈值
pool.SetBorrowWarnThreshold(30 * time.Second)

// 设置泄漏处理函数
pool.SetLeakHandler(func(leak ggm.BorrowLeak) {
    log.Printf("警告: 连接持有时间过长 %v", leak.HeldFor)
    
    // 可以发送告警、记录指标等
    sendAlert("连接泄漏检测", fmt.Sprintf("连接持有 %v", leak.HeldFor))
})
```

## ⚡ 性能优化

### 连接池调优

```go
// 根据应用负载调整连接池参数
config := ggm.Config{
    Pool: ggm.PoolConfig{
        MaxOpen:         50,  // 最大连接数，根据数据库服务器能力设置
        MaxIdle:         20,  // 空闲连接数，通常设置为 MaxOpen 的 40-50%
        ConnMaxLifetime: 10 * time.Minute, // 连接最大生命周期
        ConnMaxIdleTime: 5 * time.Minute,  // 空闲连接超时时间
    },
}
```

### 批量操作优化

```go
// 分批处理大量数据
func batchInsertUsers(pool *ggm.Pool, users []User) error {
    const batchSize = 1000
    
    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }
        
        batch := users[i:end]
        err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
            columns := []string{"name", "age", "email"}
            rows := make([][]any, len(batch))
            
            for j, user := range batch {
                rows[j] = []any{user.Name, user.Age, user.Email}
            }
            
            _, err := conn.BulkInsert(ctx, "users", columns, rows)
            return err
        })
        
        if err != nil {
            return fmt.Errorf("批次 %d-%d 插入失败: %v", i, end-1, err)
        }
        
        log.Printf("已处理 %d/%d 条记录", end, len(users))
    }
    
    return nil
}
```

### 慢查询监控

```go
// 配置慢查询阈值
config := ggm.Config{
    SlowQueryThreshold: 100 * time.Millisecond,
}

pool, err := ggm.NewPool(ctx, config)
if err != nil {
    log.Fatal(err)
}

// 慢查询会自动记录到日志中
```

## 📊 监控运维

### 健康检查

```go
// 基本健康检查
func healthCheck(pool *ggm.Pool) error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := pool.Ping(ctx); err != nil {
        return fmt.Errorf("数据库连接失败: %v", err)
    }
    
    return nil
}

// 深度健康检查
func deepHealthCheck(pool *ggm.Pool) error {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    return pool.SelfCheck(ctx)
}
```

### 连接池统计

```go
// 获取连接池统计信息
stats := pool.Stats()
log.Printf("连接池状态: 最大连接=%d, 当前打开=%d, 使用中=%d, 空闲=%d",
    stats.MaxOpenConnections,
    stats.OpenConnections,
    stats.InUse,
    stats.Idle)
```

## 🔧 故障排除

### 常见问题

#### 1. 连接超时

```go
// 增加连接超时时间
config := ggm.Config{
    Params: map[string]string{
        "timeout": "30s",
    },
}
```

#### 2. 连接数不足

```go
// 增加最大连接数
config := ggm.Config{
    Pool: ggm.PoolConfig{
        MaxOpen: 100, // 增加最大连接数
        MaxIdle: 50,  // 相应增加空闲连接数
    },
}
```

#### 3. 慢查询问题

```go
// 启用查询日志分析
config := ggm.Config{
    SlowQueryThreshold: 50 * time.Millisecond, // 降低阈值
}
```

### 错误处理

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    _, err := conn.Exec(ctx, "INSERT INTO users (email) VALUES (?)", "test@example.com")
    return err
})

if err != nil {
    // 检查具体错误类型
    if isDuplicateKeyError(err) {
        log.Println("邮箱已存在")
    } else if isConnectionError(err) {
        log.Println("数据库连接问题")
    } else {
        log.Printf("其他错误: %v", err)
    }
}
```

## 💡 最佳实践

### 1. 连接管理

- 始终使用 `WithConn` 进行连接管理
- 避免长时间持有连接
- 合理设置连接池参数

### 2. 事务使用

- 保持事务简短
- 避免在事务中执行长时间操作
- 合理处理事务冲突

### 3. 查询优化

- 使用参数化查询防止 SQL 注入
- 为频繁查询启用预编译缓存
- 大批量操作使用批量方法

### 4. 错误处理

- 区分不同类型的错误
- 实现适当的重试机制
- 记录详细的错误日志

### 5. 监控告警

- 监控连接池状态
- 设置慢查询告警
- 监控数据库性能指标

---

**更多高级用法请参考 [API 文档](./API文档.md) 和 [官方教程](./官方教程.md)。**
