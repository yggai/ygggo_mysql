# ygggo_mysql ä½¿ç”¨æ‰‹å†Œ

## ğŸ“– ç›®å½•

1. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
2. [å®‰è£…é…ç½®](#å®‰è£…é…ç½®)
3. [åŸºç¡€æ“ä½œ](#åŸºç¡€æ“ä½œ)
4. [é«˜çº§åŠŸèƒ½](#é«˜çº§åŠŸèƒ½)
5. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
6. [ç›‘æ§è¿ç»´](#ç›‘æ§è¿ç»´)
7. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)
8. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

## ğŸš€ å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
go get github.com/yggai/ygggo_mysql
```

### æœ€ç®€ç¤ºä¾‹

```go
package main

import (
    "context"
    "log"
    ggm "github.com/yggai/ygggo_mysql"
)

func main() {
    // é…ç½®æ•°æ®åº“è¿æ¥
    config := ggm.Config{
        Host:     "localhost",
        Port:     3306,
        Username: "root",
        Password: "password",
        Database: "testdb",
    }

    // åˆ›å»ºè¿æ¥æ± 
    ctx := context.Background()
    pool, err := ggm.NewPool(ctx, config)
    if err != nil {
        log.Fatal("è¿æ¥å¤±è´¥:", err)
    }
    defer pool.Close()

    // æ‰§è¡ŒæŸ¥è¯¢
    err = pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
        rows, err := conn.Query(ctx, "SELECT id, name FROM users LIMIT 10")
        if err != nil {
            return err
        }
        defer rows.Close()

        for rows.Next() {
            var id int
            var name string
            if err := rows.Scan(&id, &name); err != nil {
                return err
            }
            log.Printf("ç”¨æˆ·: ID=%d, Name=%s", id, name)
        }
        return rows.Err()
    })

    if err != nil {
        log.Printf("æŸ¥è¯¢å¤±è´¥: %v", err)
    }
}
```

## âš™ï¸ å®‰è£…é…ç½®

### ç¯å¢ƒè¦æ±‚

- Go 1.19+
- MySQL 5.7+ æˆ– 8.0+
- ç½‘ç»œè¿æ¥åˆ° MySQL æœåŠ¡å™¨

### ä¾èµ–å®‰è£…

```bash
# å®‰è£…ä¸»åº“
go get github.com/yggai/ygggo_mysql

# å¦‚æœéœ€è¦ MySQL é©±åŠ¨ï¼ˆé€šå¸¸ä¼šè‡ªåŠ¨å®‰è£…ï¼‰
go get github.com/go-sql-driver/mysql
```

### é…ç½®æ–¹å¼

#### 1. ç¨‹åºåŒ–é…ç½®

```go
config := ggm.Config{
    // åŸºç¡€è¿æ¥é…ç½®
    Host:     "localhost",
    Port:     3306,
    Username: "myuser",
    Password: "mypassword",
    Database: "mydb",
    
    // è¿æ¥å‚æ•°
    Params: map[string]string{
        "charset":   "utf8mb4",
        "parseTime": "true",
        "loc":       "Local",
    },
    
    // è¿æ¥æ± é…ç½®
    Pool: ggm.PoolConfig{
        MaxOpen:         25,
        MaxIdle:         10,
        ConnMaxLifetime: 5 * time.Minute,
        ConnMaxIdleTime: 2 * time.Minute,
    },
    
    // æ€§èƒ½é…ç½®
    SlowQueryThreshold: 100 * time.Millisecond,
}
```

#### 2. ç¯å¢ƒå˜é‡é…ç½®

```bash
export YGGGO_MYSQL_HOST=localhost
export YGGGO_MYSQL_PORT=3306
export YGGGO_MYSQL_USERNAME=myuser
export YGGGO_MYSQL_PASSWORD=mypassword
export YGGGO_MYSQL_DATABASE=mydb
```

#### 3. DSN é…ç½®

```go
config := ggm.Config{
    DSN: "user:password@tcp(localhost:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local",
}
```

## ğŸ“Š åŸºç¡€æ“ä½œ

### æŸ¥è¯¢æ“ä½œ

#### å•è¡ŒæŸ¥è¯¢

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    var user struct {
        ID   int    `db:"id"`
        Name string `db:"name"`
        Age  int    `db:"age"`
    }
    
    row := conn.QueryRow(ctx, "SELECT id, name, age FROM users WHERE id = ?", 1)
    err := row.Scan(&user.ID, &user.Name, &user.Age)
    if err != nil {
        return err
    }
    
    log.Printf("ç”¨æˆ·ä¿¡æ¯: %+v", user)
    return nil
})
```

#### å¤šè¡ŒæŸ¥è¯¢

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    rows, err := conn.Query(ctx, "SELECT id, name, age FROM users WHERE age > ?", 18)
    if err != nil {
        return err
    }
    defer rows.Close()

    var users []struct {
        ID   int
        Name string
        Age  int
    }

    for rows.Next() {
        var user struct {
            ID   int
            Name string
            Age  int
        }
        if err := rows.Scan(&user.ID, &user.Name, &user.Age); err != nil {
            return err
        }
        users = append(users, user)
    }

    log.Printf("æ‰¾åˆ° %d ä¸ªç”¨æˆ·", len(users))
    return rows.Err()
})
```

### æ’å…¥æ“ä½œ

#### å•æ¡æ’å…¥

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx, 
        "INSERT INTO users (name, age, email) VALUES (?, ?, ?)",
        "å¼ ä¸‰", 25, "zhangsan@example.com")
    if err != nil {
        return err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return err
    }
    
    log.Printf("æ’å…¥æˆåŠŸï¼Œæ–°ç”¨æˆ·ID: %d", id)
    return nil
})
```

#### æ‰¹é‡æ’å…¥

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    columns := []string{"name", "age", "email"}
    rows := [][]any{
        {"æå››", 30, "lisi@example.com"},
        {"ç‹äº”", 28, "wangwu@example.com"},
        {"èµµå…­", 35, "zhaoliu@example.com"},
    }
    
    result, err := conn.BulkInsert(ctx, "users", columns, rows)
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("æ‰¹é‡æ’å…¥æˆåŠŸï¼Œå½±å“è¡Œæ•°: %d", affected)
    return nil
})
```

### æ›´æ–°æ“ä½œ

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx,
        "UPDATE users SET age = ?, email = ? WHERE name = ?",
        26, "zhangsan_new@example.com", "å¼ ä¸‰")
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("æ›´æ–°æˆåŠŸï¼Œå½±å“è¡Œæ•°: %d", affected)
    return nil
})
```

### åˆ é™¤æ“ä½œ

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    result, err := conn.Exec(ctx, "DELETE FROM users WHERE age < ?", 18)
    if err != nil {
        return err
    }
    
    affected, _ := result.RowsAffected()
    log.Printf("åˆ é™¤æˆåŠŸï¼Œå½±å“è¡Œæ•°: %d", affected)
    return nil
})
```

## ğŸ”„ äº‹åŠ¡æ“ä½œ

### åŸºæœ¬äº‹åŠ¡

```go
err := pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
    // ç¬¬ä¸€ä¸ªæ“ä½œ
    _, err := tx.Exec(ctx, "INSERT INTO orders (user_id, amount) VALUES (?, ?)", 1, 100.00)
    if err != nil {
        return err // è‡ªåŠ¨å›æ»š
    }
    
    // ç¬¬äºŒä¸ªæ“ä½œ
    _, err = tx.Exec(ctx, "UPDATE users SET balance = balance - ? WHERE id = ?", 100.00, 1)
    if err != nil {
        return err // è‡ªåŠ¨å›æ»š
    }
    
    return nil // è‡ªåŠ¨æäº¤
})

if err != nil {
    log.Printf("äº‹åŠ¡å¤±è´¥: %v", err)
} else {
    log.Println("äº‹åŠ¡æˆåŠŸæäº¤")
}
```

### è½¬è´¦ç¤ºä¾‹

```go
func transferMoney(pool *ggm.Pool, fromID, toID int, amount float64) error {
    return pool.WithinTx(ctx, func(tx ggm.DatabaseTx) error {
        // æ£€æŸ¥å¹¶æ‰£é™¤æºè´¦æˆ·ä½™é¢
        result, err := tx.Exec(ctx,
            "UPDATE accounts SET balance = balance - ? WHERE id = ? AND balance >= ?",
            amount, fromID, amount)
        if err != nil {
            return fmt.Errorf("æ‰£æ¬¾å¤±è´¥: %v", err)
        }
        
        affected, _ := result.RowsAffected()
        if affected == 0 {
            return fmt.Errorf("ä½™é¢ä¸è¶³æˆ–è´¦æˆ·ä¸å­˜åœ¨")
        }
        
        // å¢åŠ ç›®æ ‡è´¦æˆ·ä½™é¢
        _, err = tx.Exec(ctx,
            "UPDATE accounts SET balance = balance + ? WHERE id = ?",
            amount, toID)
        if err != nil {
            return fmt.Errorf("åŠ æ¬¾å¤±è´¥: %v", err)
        }
        
        // è®°å½•è½¬è´¦æ—¥å¿—
        _, err = tx.Exec(ctx,
            "INSERT INTO transfer_logs (from_id, to_id, amount, created_at) VALUES (?, ?, ?, NOW())",
            fromID, toID, amount)
        if err != nil {
            return fmt.Errorf("è®°å½•æ—¥å¿—å¤±è´¥: %v", err)
        }
        
        return nil
    })
}
```

## ğŸš€ é«˜çº§åŠŸèƒ½

### é¢„ç¼–è¯‘è¯­å¥ç¼“å­˜

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    // å¯ç”¨è¯­å¥ç¼“å­˜
    conn.EnableStmtCache(100)
    
    // é‡å¤æ‰§è¡Œçš„æŸ¥è¯¢ä¼šè‡ªåŠ¨ä½¿ç”¨ç¼“å­˜
    for i := 0; i < 1000; i++ {
        _, err := conn.ExecCached(ctx,
            "INSERT INTO logs (level, message, created_at) VALUES (?, ?, NOW())",
            "INFO", fmt.Sprintf("å¤„ç†ä»»åŠ¡ %d", i))
        if err != nil {
            return err
        }
    }
    
    return nil
})
```

### å‘½åå‚æ•°æŸ¥è¯¢

```go
type User struct {
    Name  string `db:"name"`
    Age   int    `db:"age"`
    Email string `db:"email"`
}

err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    user := User{
        Name:  "å¼ ä¸‰",
        Age:   25,
        Email: "zhangsan@example.com",
    }
    
    _, err := conn.NamedExec(ctx,
        "INSERT INTO users (name, age, email) VALUES (:name, :age, :email)",
        user)
    return err
})
```

### æµå¼æŸ¥è¯¢

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    return conn.QueryStream(ctx,
        "SELECT id, name, data FROM large_table",
        func(row []any) error {
            id := row[0].(int64)
            name := row[1].(string)
            data := row[2].([]byte)
            
            // å¤„ç†æ¯ä¸€è¡Œæ•°æ®
            log.Printf("å¤„ç†è®°å½•: ID=%d, Name=%s, DataSize=%d", id, name, len(data))
            
            // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œå¤æ‚çš„æ•°æ®å¤„ç†
            return processData(id, name, data)
        })
})
```

### è¿æ¥æ³„æ¼æ£€æµ‹

```go
// è®¾ç½®è¿æ¥æŒæœ‰æ—¶é—´è­¦å‘Šé˜ˆå€¼
pool.SetBorrowWarnThreshold(30 * time.Second)

// è®¾ç½®æ³„æ¼å¤„ç†å‡½æ•°
pool.SetLeakHandler(func(leak ggm.BorrowLeak) {
    log.Printf("è­¦å‘Š: è¿æ¥æŒæœ‰æ—¶é—´è¿‡é•¿ %v", leak.HeldFor)
    
    // å¯ä»¥å‘é€å‘Šè­¦ã€è®°å½•æŒ‡æ ‡ç­‰
    sendAlert("è¿æ¥æ³„æ¼æ£€æµ‹", fmt.Sprintf("è¿æ¥æŒæœ‰ %v", leak.HeldFor))
})
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### è¿æ¥æ± è°ƒä¼˜

```go
// æ ¹æ®åº”ç”¨è´Ÿè½½è°ƒæ•´è¿æ¥æ± å‚æ•°
config := ggm.Config{
    Pool: ggm.PoolConfig{
        MaxOpen:         50,  // æœ€å¤§è¿æ¥æ•°ï¼Œæ ¹æ®æ•°æ®åº“æœåŠ¡å™¨èƒ½åŠ›è®¾ç½®
        MaxIdle:         20,  // ç©ºé—²è¿æ¥æ•°ï¼Œé€šå¸¸è®¾ç½®ä¸º MaxOpen çš„ 40-50%
        ConnMaxLifetime: 10 * time.Minute, // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
        ConnMaxIdleTime: 5 * time.Minute,  // ç©ºé—²è¿æ¥è¶…æ—¶æ—¶é—´
    },
}
```

### æ‰¹é‡æ“ä½œä¼˜åŒ–

```go
// åˆ†æ‰¹å¤„ç†å¤§é‡æ•°æ®
func batchInsertUsers(pool *ggm.Pool, users []User) error {
    const batchSize = 1000
    
    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }
        
        batch := users[i:end]
        err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
            columns := []string{"name", "age", "email"}
            rows := make([][]any, len(batch))
            
            for j, user := range batch {
                rows[j] = []any{user.Name, user.Age, user.Email}
            }
            
            _, err := conn.BulkInsert(ctx, "users", columns, rows)
            return err
        })
        
        if err != nil {
            return fmt.Errorf("æ‰¹æ¬¡ %d-%d æ’å…¥å¤±è´¥: %v", i, end-1, err)
        }
        
        log.Printf("å·²å¤„ç† %d/%d æ¡è®°å½•", end, len(users))
    }
    
    return nil
}
```

### æ…¢æŸ¥è¯¢ç›‘æ§

```go
// é…ç½®æ…¢æŸ¥è¯¢é˜ˆå€¼
config := ggm.Config{
    SlowQueryThreshold: 100 * time.Millisecond,
}

pool, err := ggm.NewPool(ctx, config)
if err != nil {
    log.Fatal(err)
}

// æ…¢æŸ¥è¯¢ä¼šè‡ªåŠ¨è®°å½•åˆ°æ—¥å¿—ä¸­
```

## ğŸ“Š ç›‘æ§è¿ç»´

### å¥åº·æ£€æŸ¥

```go
// åŸºæœ¬å¥åº·æ£€æŸ¥
func healthCheck(pool *ggm.Pool) error {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := pool.Ping(ctx); err != nil {
        return fmt.Errorf("æ•°æ®åº“è¿æ¥å¤±è´¥: %v", err)
    }
    
    return nil
}

// æ·±åº¦å¥åº·æ£€æŸ¥
func deepHealthCheck(pool *ggm.Pool) error {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    return pool.SelfCheck(ctx)
}
```

### è¿æ¥æ± ç»Ÿè®¡

```go
// è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
stats := pool.Stats()
log.Printf("è¿æ¥æ± çŠ¶æ€: æœ€å¤§è¿æ¥=%d, å½“å‰æ‰“å¼€=%d, ä½¿ç”¨ä¸­=%d, ç©ºé—²=%d",
    stats.MaxOpenConnections,
    stats.OpenConnections,
    stats.InUse,
    stats.Idle)
```

## ğŸ”§ æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. è¿æ¥è¶…æ—¶

```go
// å¢åŠ è¿æ¥è¶…æ—¶æ—¶é—´
config := ggm.Config{
    Params: map[string]string{
        "timeout": "30s",
    },
}
```

#### 2. è¿æ¥æ•°ä¸è¶³

```go
// å¢åŠ æœ€å¤§è¿æ¥æ•°
config := ggm.Config{
    Pool: ggm.PoolConfig{
        MaxOpen: 100, // å¢åŠ æœ€å¤§è¿æ¥æ•°
        MaxIdle: 50,  // ç›¸åº”å¢åŠ ç©ºé—²è¿æ¥æ•°
    },
}
```

#### 3. æ…¢æŸ¥è¯¢é—®é¢˜

```go
// å¯ç”¨æŸ¥è¯¢æ—¥å¿—åˆ†æ
config := ggm.Config{
    SlowQueryThreshold: 50 * time.Millisecond, // é™ä½é˜ˆå€¼
}
```

### é”™è¯¯å¤„ç†

```go
err := pool.WithConn(ctx, func(conn ggm.DatabaseConn) error {
    _, err := conn.Exec(ctx, "INSERT INTO users (email) VALUES (?)", "test@example.com")
    return err
})

if err != nil {
    // æ£€æŸ¥å…·ä½“é”™è¯¯ç±»å‹
    if isDuplicateKeyError(err) {
        log.Println("é‚®ç®±å·²å­˜åœ¨")
    } else if isConnectionError(err) {
        log.Println("æ•°æ®åº“è¿æ¥é—®é¢˜")
    } else {
        log.Printf("å…¶ä»–é”™è¯¯: %v", err)
    }
}
```

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. è¿æ¥ç®¡ç†

- å§‹ç»ˆä½¿ç”¨ `WithConn` è¿›è¡Œè¿æ¥ç®¡ç†
- é¿å…é•¿æ—¶é—´æŒæœ‰è¿æ¥
- åˆç†è®¾ç½®è¿æ¥æ± å‚æ•°

### 2. äº‹åŠ¡ä½¿ç”¨

- ä¿æŒäº‹åŠ¡ç®€çŸ­
- é¿å…åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œé•¿æ—¶é—´æ“ä½œ
- åˆç†å¤„ç†äº‹åŠ¡å†²çª

### 3. æŸ¥è¯¢ä¼˜åŒ–

- ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢ SQL æ³¨å…¥
- ä¸ºé¢‘ç¹æŸ¥è¯¢å¯ç”¨é¢„ç¼–è¯‘ç¼“å­˜
- å¤§æ‰¹é‡æ“ä½œä½¿ç”¨æ‰¹é‡æ–¹æ³•

### 4. é”™è¯¯å¤„ç†

- åŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯
- å®ç°é€‚å½“çš„é‡è¯•æœºåˆ¶
- è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—

### 5. ç›‘æ§å‘Šè­¦

- ç›‘æ§è¿æ¥æ± çŠ¶æ€
- è®¾ç½®æ…¢æŸ¥è¯¢å‘Šè­¦
- ç›‘æ§æ•°æ®åº“æ€§èƒ½æŒ‡æ ‡

---

**æ›´å¤šé«˜çº§ç”¨æ³•è¯·å‚è€ƒ [API æ–‡æ¡£](./APIæ–‡æ¡£.md) å’Œ [å®˜æ–¹æ•™ç¨‹](./å®˜æ–¹æ•™ç¨‹.md)ã€‚**
